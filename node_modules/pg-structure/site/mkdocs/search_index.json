{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to pg-structure\n\n\npg-structure\n is a Node.js library to get structure of a \nPostgreSQL\n database automatically as a detailed object.\n\n\n\n    \n\n        \n\n            \nTested\n\n            Every part of the library is tested.\n        \n\n        \n\n            \nDocumented\n\n            Everything is documented, no hidden features.\n        \n\n        \n\n            \nUtilitarian\n\n            Beyond database objects (i.e. \nmany to many relation\n, \ndescription data\n).\n        \n\n    \n\n\n\n\n\npg-structure examines given PostgreSQL database by reverse engineering and lets you easily code, analyze, operate on PostgreSQL database structure by providing details about \nDB\n, \nSchema\n, \nTable\n, \nColumn\n, \nConstraint\n, \nRelation\n and \nIndex\n.\n\n\nCreated object can be used to auto generate documentation or ORM models from database. It is much easier to work with JS object than working manually with database.\n\n\nExample\n\n\nvar pgStructure = require('pg-structure');\n\npgStructure({database: 'db', user: 'user', password: 'password'}, ['public', 'other_schema'])\n    .then((db) =\n { console.log( db.get('public.account').columns.get('is_active').type ); })\n    .catch(err =\n console.log(err.stack));\n\n\n\nDetailed Example\n\n\nvar pgStructure = require('pg-structure');\n\npgStructure({database: 'db', user: 'user', password: 'password', host: 'localhost', port: 5432}, ['public', 'other_schema'])\n    .then((db) =\n {\n        // Basic\n        var tables = db.schemas.get('public').tables;  // Map of Table objects.\n\n        // List of table names\n        for (let table of tables.values()) {\n            console.log(table.name);\n        }\n\n        // Long chain example for:\n        // public schema -\n cart table -\n contact_id column -\n foreign key constraints of contact_id.\n        var constraints = db.get('public.cart.contact_id').foreignKeyConstraints;\n        var sameName = db.schemas.get('public').tables.get('cart').columns.get('contact_id').foreignKeyConstraints;\n\n        // Many to many relation. Returns cart_line_item for cart --\n cart_line_item \n-- product\n        var joinTable = [...db.get('public.cart').m2mRelations.values()][0].joinTable;    // See JS Map  on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Map\n    })\n    .catch(err =\n console.log(err.stack));\n\n\n\nLoad \n Save Example\n\n\nYou can save reverse engineered database for later to load. If you use \n.zip\n extension, pg-structure automatically\ncompresses file as zip file. \n\n\nvar pgStructure = require('pg-structure');\n\npgStructure({database: 'db', user: 'user', password: 'password', host: 'localhost', port: 5432}, ['public', 'other_schema'])\n    .then(db =\n pgStructure.save('./db.zip', db))\n    .catch(err =\n console.log(err.stack));\n\n\n\n... Later, you can load pg-structure. Loading is 10 times faster than reverse engineering database.  \n\n\nvar pgStructure = require('pg-structure');\n\npgStructure.load('./db.zip')\n    .then(db =\n console.log(db.schemas.get('public').name))\n    .catch(err =\n console.log(err.stack));\n\n\n\nCaveat\n: pgStructure cannot\nload files saved by incompatible pg-structure module versions and returns \nundefined\n. In this case you should\nfetch structure from database and create a new save file.\n\n\nFeatures\n\n\n\n\nFully tested\n\n\nFully documented with JSDOC and HTML\n\n\nSupports load, save, serialize, deserialize, toString, parse.\n\n\nAll PostgreSQL data types including array, JSON and HSTore\n\n\nSupport composite keys (Multiple field keys)\n\n\nSchema support\n\n\nConstraints (Primary Key, Foreign Key, Unique).\n\n\nSupports multi-column constraints.\n\n\nIdentifies one to many (hasMany) relationships.\n\n\nIdentifies reverse of one to many (belongsTo) relationships\n\n\nIdentifies all possible many to many (belongs to many \n has many through) relationships\n\n\nObjects can be accessed by name or by order. (Uses Map to save order and allow named access.)\n\n\nObjects can be iterated via callbacks.\n\n\nAllows to store and extract JSON data from Database objects. (See Description Data in \nconcepts\n.)\n\n\nVery detailed column meta data:\n\n\nAllow null\n\n\nDescription\n\n\nAuto Increment\n\n\nonUpdate\n\n\nonDelete\n\n\netc. (Full details can be found in \nColumn\n doc)\n\n\n\n\n\n\nSupport for:\n\n\nDB\n\n\nSchema\n\n\nTable\n\n\nColumn\n\n\nConstraint\n\n\nIndex\n\n\nRelation\n\n\n\n\n\n\n\n\nWhere to Start?\n\n\nFirst have look at \nconcepts\n to understand a few key points.\nYou may want to read \nexamples\n to see how \npg-structure\n can be used.\nTo start coding read main \npg-structure\n module's documentation.\nDuring development API references helps you.\n\n\nSpecial Thanks\n\n\npg-structure\n is developed under sponsorship of \nFortibase\n and released as open source. See \nlicense\n.\n\n\nAlso documentation is auto generated thanks to:\n\n\n\n\nMkDocs\n using a \ntheme\n provided by \nRead the Docs\n.\n\n\nMarkdown is generated by \njsdoc-to-markdown\n\n\n\n\nContributions\n\n\n\n\nFor contribution please send pull requests with tests on \nGitHub\n.\n\n\nSend bugs and feature requests to \nGitHub Issues\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-pg-structure", 
            "text": "pg-structure  is a Node.js library to get structure of a  PostgreSQL  database automatically as a detailed object.  \n     \n         \n             Tested \n            Every part of the library is tested.\n         \n         \n             Documented \n            Everything is documented, no hidden features.\n         \n         \n             Utilitarian \n            Beyond database objects (i.e.  many to many relation ,  description data ).\n         \n       pg-structure examines given PostgreSQL database by reverse engineering and lets you easily code, analyze, operate on PostgreSQL database structure by providing details about  DB ,  Schema ,  Table ,  Column ,  Constraint ,  Relation  and  Index .  Created object can be used to auto generate documentation or ORM models from database. It is much easier to work with JS object than working manually with database.", 
            "title": "Welcome to pg-structure"
        }, 
        {
            "location": "/#example", 
            "text": "var pgStructure = require('pg-structure');\n\npgStructure({database: 'db', user: 'user', password: 'password'}, ['public', 'other_schema'])\n    .then((db) =  { console.log( db.get('public.account').columns.get('is_active').type ); })\n    .catch(err =  console.log(err.stack));", 
            "title": "Example"
        }, 
        {
            "location": "/#detailed-example", 
            "text": "var pgStructure = require('pg-structure');\n\npgStructure({database: 'db', user: 'user', password: 'password', host: 'localhost', port: 5432}, ['public', 'other_schema'])\n    .then((db) =  {\n        // Basic\n        var tables = db.schemas.get('public').tables;  // Map of Table objects.\n\n        // List of table names\n        for (let table of tables.values()) {\n            console.log(table.name);\n        }\n\n        // Long chain example for:\n        // public schema -  cart table -  contact_id column -  foreign key constraints of contact_id.\n        var constraints = db.get('public.cart.contact_id').foreignKeyConstraints;\n        var sameName = db.schemas.get('public').tables.get('cart').columns.get('contact_id').foreignKeyConstraints;\n\n        // Many to many relation. Returns cart_line_item for cart --  cart_line_item  -- product\n        var joinTable = [...db.get('public.cart').m2mRelations.values()][0].joinTable;    // See JS Map  on https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Map\n    })\n    .catch(err =  console.log(err.stack));", 
            "title": "Detailed Example"
        }, 
        {
            "location": "/#load-save-example", 
            "text": "You can save reverse engineered database for later to load. If you use  .zip  extension, pg-structure automatically\ncompresses file as zip file.   var pgStructure = require('pg-structure');\n\npgStructure({database: 'db', user: 'user', password: 'password', host: 'localhost', port: 5432}, ['public', 'other_schema'])\n    .then(db =  pgStructure.save('./db.zip', db))\n    .catch(err =  console.log(err.stack));  ... Later, you can load pg-structure. Loading is 10 times faster than reverse engineering database.    var pgStructure = require('pg-structure');\n\npgStructure.load('./db.zip')\n    .then(db =  console.log(db.schemas.get('public').name))\n    .catch(err =  console.log(err.stack));  Caveat : pgStructure cannot\nload files saved by incompatible pg-structure module versions and returns  undefined . In this case you should\nfetch structure from database and create a new save file.", 
            "title": "Load &amp; Save Example"
        }, 
        {
            "location": "/#features", 
            "text": "Fully tested  Fully documented with JSDOC and HTML  Supports load, save, serialize, deserialize, toString, parse.  All PostgreSQL data types including array, JSON and HSTore  Support composite keys (Multiple field keys)  Schema support  Constraints (Primary Key, Foreign Key, Unique).  Supports multi-column constraints.  Identifies one to many (hasMany) relationships.  Identifies reverse of one to many (belongsTo) relationships  Identifies all possible many to many (belongs to many   has many through) relationships  Objects can be accessed by name or by order. (Uses Map to save order and allow named access.)  Objects can be iterated via callbacks.  Allows to store and extract JSON data from Database objects. (See Description Data in  concepts .)  Very detailed column meta data:  Allow null  Description  Auto Increment  onUpdate  onDelete  etc. (Full details can be found in  Column  doc)    Support for:  DB  Schema  Table  Column  Constraint  Index  Relation", 
            "title": "Features"
        }, 
        {
            "location": "/#where-to-start", 
            "text": "First have look at  concepts  to understand a few key points.\nYou may want to read  examples  to see how  pg-structure  can be used.\nTo start coding read main  pg-structure  module's documentation.\nDuring development API references helps you.", 
            "title": "Where to Start?"
        }, 
        {
            "location": "/#special-thanks", 
            "text": "pg-structure  is developed under sponsorship of  Fortibase  and released as open source. See  license .  Also documentation is auto generated thanks to:   MkDocs  using a  theme  provided by  Read the Docs .  Markdown is generated by  jsdoc-to-markdown", 
            "title": "Special Thanks"
        }, 
        {
            "location": "/#contributions", 
            "text": "For contribution please send pull requests with tests on  GitHub .  Send bugs and feature requests to  GitHub Issues .", 
            "title": "Contributions"
        }, 
        {
            "location": "/concepts/", 
            "text": "Database Objects vs. pg-structure Objects\n\n\nIn this documentation \ndatabase objects\n means database parts provided by PostgreSQL such as table, column, constraint etc. Sometimes those objects are simply refereed as \ndatabase\n as a general term in this documentation.\n\n\npg-structure objects\n means object instances provided by pg-structure classes.\n\n\nObjects (Instances)\n\n\nIn \npg-structure\n database objects such as Schema, Column etc. are represented by JavaScript objects such as \nSchema\n, \nColumn\n etc.\n\n\npgStructure(connectionArgs, schemas).then((db) =\n {\n    // db is an DB object.\n});\n\n\n\n\nAttributes\n\n\npg-structure\n objects attributes are designed to be read only. They access various database objects' details. Attributes are \nread only\n and formed as \nnouns\n.\n\n\nUnlike previous versions of \npg-structure\n, current version does not enforce read only behaviour for the sake of new performance oriented design.\n\n\n\n\nSingular named attributes such as \ntable#name\n contains single data which is a simple JavaScript type.\n\n\nPlural named attributes such as \ntable#columns\n contains array of related objects.\n\n\nPlural named attributes with suffix \nByName\n such as \ntable#columnsByName\n contains a simple object as key/value pairs. Keys are object's names, values are related objects.\n\n\n\n\nMethods\n\n\npg-structure\n also provides methods to access database details.\n\n\nMethods are named as verbs like \nTable#getPrimaryKeys\n or \nTable#columnExists\n.\n\n\nget\n shortcut\n\n\nDB\n, \nschema\n, \ntable\n classes provide \nget\n method for a shortcut. This method may be used to save a few key strokes.\n\n\nFor example all below are equal:\n\n\nvar userColumn      = db.get('public.account.user_name');\nvar sameColumn      = db.getSchema('public').getTable('account').getColumn('user_name');\nvar againSameColumn = db.schemasByName.public.tablesByName.account.columnsByName.user_name;\n\nconsole.log(userColumn === sameColumn); // true \n\n\n\n\nRelation Classes vs. Foreign Key Constraint\n\n\npg-structure\n Foreign Key Constraint objects represent directly PostgreSQL foreign key constraints.\n\n\nDevelopers and ORM users need to have more information about relations than present in foreign key constraints. For example many to many relationships and many to one relationships are not available in database engine. \npg-structure\n provides \nO2MRelation\n, \nM2MRelation\n and \nM2ORelation\n classes to answer those needs.\n\n\nDescription Data / Comment Data\n\n\nPostgreSQL objects holds free form text in their description. \npg-structure\n offers some help to store extra data in database objects' description as JSON. \npg-structure\n automatically parses JSON data between \n[pg-structure]\nand \n[/pg-structure]\n tags. Tags are case-insensitive. Only one \npg-structure\n object is processed per description.\n\n\nFor maximum comfort JSON parsing is made by \njsonic\n. It is a non-strict JSON parser. \n\n\n\n\nYou don't need to quote property names: { foo:\"bar baz\", red:255 }\n\n\nYou don't need the top level braces: foo:\"bar baz\", red:255\n\n\nYou don't need to quote strings with spaces: foo:bar baz, red:255\n\n\nYou do need to quote strings if they contain a comma or closing brace or square bracket: icky:\",}]\"\n\n\nYou can use single quotes for strings: Jules:'Cry \"Havoc,\" and let slip the dogs of war!'\n\n\nYou can have trailing commas: foo:bar, red:255,\n\n\n\n\nFor details, please see \njsonic\n.\n\n\n// For example: 'This constraint connects account table to contact\n// table. [pg-structure]{ hasMany: primaryContacts, belongsTo: primaryAccount, free: 3 }[/pg-structure]'\n\nlet description = constraint.description;           // -\n 'This constraint connects account table to contact table.' (Tags and JSON data are replaced from description.)  \nlet data = constraint.descriptionData;              // -\n { hasMany: 'primaryContacts', belongsTo: 'primaryAccount', free: 3 }\nconsole.log(constraint.descriptionData.hasMany);    // -\n primaryContacts", 
            "title": "Concepts"
        }, 
        {
            "location": "/concepts/#database-objects-vs-pg-structure-objects", 
            "text": "In this documentation  database objects  means database parts provided by PostgreSQL such as table, column, constraint etc. Sometimes those objects are simply refereed as  database  as a general term in this documentation.  pg-structure objects  means object instances provided by pg-structure classes.", 
            "title": "Database Objects vs. pg-structure Objects"
        }, 
        {
            "location": "/concepts/#objects-instances", 
            "text": "In  pg-structure  database objects such as Schema, Column etc. are represented by JavaScript objects such as  Schema ,  Column  etc.  pgStructure(connectionArgs, schemas).then((db) =  {\n    // db is an DB object.\n});", 
            "title": "Objects (Instances)"
        }, 
        {
            "location": "/concepts/#attributes", 
            "text": "pg-structure  objects attributes are designed to be read only. They access various database objects' details. Attributes are  read only  and formed as  nouns .  Unlike previous versions of  pg-structure , current version does not enforce read only behaviour for the sake of new performance oriented design.   Singular named attributes such as  table#name  contains single data which is a simple JavaScript type.  Plural named attributes such as  table#columns  contains array of related objects.  Plural named attributes with suffix  ByName  such as  table#columnsByName  contains a simple object as key/value pairs. Keys are object's names, values are related objects.", 
            "title": "Attributes"
        }, 
        {
            "location": "/concepts/#methods", 
            "text": "pg-structure  also provides methods to access database details.  Methods are named as verbs like  Table#getPrimaryKeys  or  Table#columnExists .", 
            "title": "Methods"
        }, 
        {
            "location": "/concepts/#get-shortcut", 
            "text": "DB ,  schema ,  table  classes provide  get  method for a shortcut. This method may be used to save a few key strokes.  For example all below are equal:  var userColumn      = db.get('public.account.user_name');\nvar sameColumn      = db.getSchema('public').getTable('account').getColumn('user_name');\nvar againSameColumn = db.schemasByName.public.tablesByName.account.columnsByName.user_name;\n\nconsole.log(userColumn === sameColumn); // true", 
            "title": "get shortcut"
        }, 
        {
            "location": "/concepts/#relation-classes-vs-foreign-key-constraint", 
            "text": "pg-structure  Foreign Key Constraint objects represent directly PostgreSQL foreign key constraints.  Developers and ORM users need to have more information about relations than present in foreign key constraints. For example many to many relationships and many to one relationships are not available in database engine.  pg-structure  provides  O2MRelation ,  M2MRelation  and  M2ORelation  classes to answer those needs.", 
            "title": "Relation Classes vs. Foreign Key Constraint"
        }, 
        {
            "location": "/concepts/#description-data-comment-data", 
            "text": "PostgreSQL objects holds free form text in their description.  pg-structure  offers some help to store extra data in database objects' description as JSON.  pg-structure  automatically parses JSON data between  [pg-structure] and  [/pg-structure]  tags. Tags are case-insensitive. Only one  pg-structure  object is processed per description.  For maximum comfort JSON parsing is made by  jsonic . It is a non-strict JSON parser.    You don't need to quote property names: { foo:\"bar baz\", red:255 }  You don't need the top level braces: foo:\"bar baz\", red:255  You don't need to quote strings with spaces: foo:bar baz, red:255  You do need to quote strings if they contain a comma or closing brace or square bracket: icky:\",}]\"  You can use single quotes for strings: Jules:'Cry \"Havoc,\" and let slip the dogs of war!'  You can have trailing commas: foo:bar, red:255,   For details, please see  jsonic .  // For example: 'This constraint connects account table to contact\n// table. [pg-structure]{ hasMany: primaryContacts, belongsTo: primaryAccount, free: 3 }[/pg-structure]'\n\nlet description = constraint.description;           // -  'This constraint connects account table to contact table.' (Tags and JSON data are replaced from description.)  \nlet data = constraint.descriptionData;              // -  { hasMany: 'primaryContacts', belongsTo: 'primaryAccount', free: 3 }\nconsole.log(constraint.descriptionData.hasMany);    // -  primaryContacts", 
            "title": "Description Data / Comment Data"
        }, 
        {
            "location": "/examples/", 
            "text": "Database Schema\n\n\n\n\nExamples are based on a sample database schema above. \n\n\nExamples\n\n\nGet Tables as a {@link Map}\n\n\nvar tablesArray  = db.get('public').tables;         // Map { size =\n Table {}, color =\n Table {}, line_item =\n Table {} ... }\n\n\n\n\nGet Columns\n\n\nvar columnsArray  = [...db.get('public.product').columns.values()];  // [ id {}, name {}, color_id {} ... ]\nfor (let column of db.get('public.product').columns.values()) {\n    console.log(column.name);\n}\n\n\n\n\nGet Primary Keys\n\n\nvar pkArray  = db.get('public.product').primaryKeyColumns; // Map { ... }\n\n\n\n\nGet Foreign Key Columns\n\n\nTo get all foreign key columns of all foreign key constraints in a table:\n\n\nvar fkMap  = db.get('public.product').foreignKeyColumns; // Map { color_id =\n Column {}, vendor_id =\n Column {}  }\n\n\n\n\nTo get foreign key columns of a specific constraint:\n\n\nvar fkMap  = db.get('public.product').foreignKeyConstraints.get('vendor_has_products').columns; // Map { vendor_id =\n Column {} }\n\n\n\n\nOne to Many Relation\n\n\nvar  relation         = [...product.o2mRelations.values()][0];              // RELATION:    product ---\n line_item\nvar  constraint       = relation.constraint;                                // CONSTRAINT:           ^-- product_has_carts\nvar  sourceTable      = relation.sourceTable;                               // TABLE:       product\nvar  targetTable      = relation.targetTable;                               // TABLE:       line_item\nvar  FKColumn         = [...relation.constraint.columns.values()][0];       // COLUMN:      product_id  (from line_item table)\nvar  sourcePKColumn   = [...relation.sourceTable.primaryKeys.values()][0];  // COLUMN:      id          (from product table)\n\n\n\n\nMany to Many Relation\n\n\nvar relation             = [...product.m2mRelations.values()][0];               // RELATION:    product ---\n line_item \n--- cart\nvar sourceConstraint     = relation.sourceConstraint;                           // CONSTRAINT:           ^-- product_has_carts\nvar targetConstraint     = relation.targetConstraint;                           // CONSTRAINT:       cart_has_products --^\nvar sourceTable          = relation.sourceTable;                                // TABLE:       product\nvar targetTable          = relation.targetTable;                                // TABLE:       cart\nvar sourceJoinFKColumn   = [...relation.sourceConstraint.columns.values()][0];  // COLUMN:      product_id  (from line_item table)\nvar targetJoinFKColumn   = [...relation.targetConstraint.columns.values()][0];  // COLUMN:      cart_id     (from line_item table)\nvar sourcePKColumn       = [...relation.sourceTable.primaryKeys.values()][0];   // COLUMN:      id          (from product table)\nvar targetPKColumn       = [...relation.targetTable.primaryKeys.values()][0];   // COLUMN:      id          (from cart table)\n\n\n\n\nMany to One Relation\n\n\nvar  relation     = [...line_item.m2oRelations.values()][0];            // RELATION:    line_item \n---- product\nvar  constraint   = relation.constraint;                                // CONSTRAINT:               ^-- product_has_carts\nvar  sourceTable  = relation.sourceTable;                               // TABLE:       line_item\nvar  targetTable  = relation.targetTable;                               // TABLE:       product\nvar  FKColumn     = [...relation.constraint.columns.values()][0];       // COLUMN:      product_id  (from line_item table)\nvar  PKColumn     = [...relation.targetTable.primaryKeys.values()][0];  // COLUMN:      id          (from product table)", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#database-schema", 
            "text": "Examples are based on a sample database schema above.", 
            "title": "Database Schema"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#get-tables-as-a-link-map", 
            "text": "var tablesArray  = db.get('public').tables;         // Map { size =  Table {}, color =  Table {}, line_item =  Table {} ... }", 
            "title": "Get Tables as a {@link Map}"
        }, 
        {
            "location": "/examples/#get-columns", 
            "text": "var columnsArray  = [...db.get('public.product').columns.values()];  // [ id {}, name {}, color_id {} ... ]\nfor (let column of db.get('public.product').columns.values()) {\n    console.log(column.name);\n}", 
            "title": "Get Columns"
        }, 
        {
            "location": "/examples/#get-primary-keys", 
            "text": "var pkArray  = db.get('public.product').primaryKeyColumns; // Map { ... }", 
            "title": "Get Primary Keys"
        }, 
        {
            "location": "/examples/#get-foreign-key-columns", 
            "text": "To get all foreign key columns of all foreign key constraints in a table:  var fkMap  = db.get('public.product').foreignKeyColumns; // Map { color_id =  Column {}, vendor_id =  Column {}  }  To get foreign key columns of a specific constraint:  var fkMap  = db.get('public.product').foreignKeyConstraints.get('vendor_has_products').columns; // Map { vendor_id =  Column {} }", 
            "title": "Get Foreign Key Columns"
        }, 
        {
            "location": "/examples/#one-to-many-relation", 
            "text": "var  relation         = [...product.o2mRelations.values()][0];              // RELATION:    product ---  line_item\nvar  constraint       = relation.constraint;                                // CONSTRAINT:           ^-- product_has_carts\nvar  sourceTable      = relation.sourceTable;                               // TABLE:       product\nvar  targetTable      = relation.targetTable;                               // TABLE:       line_item\nvar  FKColumn         = [...relation.constraint.columns.values()][0];       // COLUMN:      product_id  (from line_item table)\nvar  sourcePKColumn   = [...relation.sourceTable.primaryKeys.values()][0];  // COLUMN:      id          (from product table)", 
            "title": "One to Many Relation"
        }, 
        {
            "location": "/examples/#many-to-many-relation", 
            "text": "var relation             = [...product.m2mRelations.values()][0];               // RELATION:    product ---  line_item  --- cart\nvar sourceConstraint     = relation.sourceConstraint;                           // CONSTRAINT:           ^-- product_has_carts\nvar targetConstraint     = relation.targetConstraint;                           // CONSTRAINT:       cart_has_products --^\nvar sourceTable          = relation.sourceTable;                                // TABLE:       product\nvar targetTable          = relation.targetTable;                                // TABLE:       cart\nvar sourceJoinFKColumn   = [...relation.sourceConstraint.columns.values()][0];  // COLUMN:      product_id  (from line_item table)\nvar targetJoinFKColumn   = [...relation.targetConstraint.columns.values()][0];  // COLUMN:      cart_id     (from line_item table)\nvar sourcePKColumn       = [...relation.sourceTable.primaryKeys.values()][0];   // COLUMN:      id          (from product table)\nvar targetPKColumn       = [...relation.targetTable.primaryKeys.values()][0];   // COLUMN:      id          (from cart table)", 
            "title": "Many to Many Relation"
        }, 
        {
            "location": "/examples/#many-to-one-relation", 
            "text": "var  relation     = [...line_item.m2oRelations.values()][0];            // RELATION:    line_item  ---- product\nvar  constraint   = relation.constraint;                                // CONSTRAINT:               ^-- product_has_carts\nvar  sourceTable  = relation.sourceTable;                               // TABLE:       line_item\nvar  targetTable  = relation.targetTable;                               // TABLE:       product\nvar  FKColumn     = [...relation.constraint.columns.values()][0];       // COLUMN:      product_id  (from line_item table)\nvar  PKColumn     = [...relation.targetTable.primaryKeys.values()][0];  // COLUMN:      id          (from product table)", 
            "title": "Many to One Relation"
        }, 
        {
            "location": "/history/", 
            "text": "Note\n: Version history for minimal documentation updates are not listed here to prevent cluttering.\n\n\nHistory \n Release Notes\n\n\n3.5.14 / 2017-03-06\n\n\n\n\nFixed: If same constraint name is used more than once in same schema (non-unique constraint name), pg-structure was failing.\n\n\n\n\n3.5.11 / 2017-02-21\n\n\n\n\nFixed: Column.default() was returning typecast if default value is ''. \n\n\n\n\n3.5.0 / 2016-05-04\n\n\n\n\nAdded: Relation naming support for CamelCase tables.\n\n\nFixed: Default strategy for Many to Many (\nm2m\n) and Many to One (\nm2o\n) relations are selected as 'simple' even 'simple' strategy causes conflict. Now complex is selected when there are conflicts between cross types of \no2m\n and \nm2m\n.\n\n\nAdded: Relation naming documentation.\n\n\nAdded: Naming strategy test.\n\n\n\n\n3.4.0\n\n\n\n\nChanged: \ntable#descriptionData\n tag is changed from \n[JSON]\n to \n[pg-structure]\n\n\n(EXPERIMENTAL) Added: \no2mRelation#generateName()\n, \nm2oRelation#generateName()\n, \nm2mRelation#generateName()\n. Those methods are highly experimental and may be changed or deleted.\n\n\n\n\n3.3.2 / 2016-02-25\n\n\n\n\nFixed: Tables without primary key was throwing exception for \ntable#primaryKeyColumns\n.\n\n\nFixed: \ntable#hasManyTables\n and \ntable#belongsToTables\n were returning array instead of Set.\n\n\n\n\n3.3.0 / 2016-02-24\n\n\n\n\nAdded: \ntable#descriptionData\n, \ntable#commentData\n, \ncolumn#descriptionData\n, \ncolumn#commentData\n, \nconstraint#descriptionData\n, \nconstraint#commentData\n. It is possible to store and access JSON in objects' description.\n\n\n\n\n3.2.0 / 2016-02-24\n\n\n\n\nAdded:\nconstraint#description\n, \nconstraint#comment\n.\n\n\nUpdated: Test ERD corrected.\n\n\n\n\n3.1.1 / 2016-01-30\n\n\n\n\nAdded: \ncolumn#referencedColumns\n.\n\n\n\n\n3.1.0 / 2016-01-26\n\n\n\n\nAdded: \n#array\n method is added all Map types to help building arrays in non supporting environments such as nunjucks.\n\n\n\n\n3.0.0 / 2016-01-16\n\n\nPrevious versions of pg-structure are designed to be a build time tool. v3 are designed to be a runtime tool. It is refactored to better performance compared to previous versions.\nInternal storage is completely rewritten. Loki DB is excellent product, but it is overkill for this project. pg-structure now uses direct object references for speed up things.\nDB interaction is reduced from 9 SQL queries to 3. Those 3 queries are same queries from previous version. So work of other 6 queries are done by Javascript now.\n\n\n\n\nBreaking Change: \nColumn#foreignKeyConstraint\n is changed to \nColumn#foreignKeyConstraints\n, \nColumn#referencedColumn\n is removed,\nbecause same column may be part of multiple different foreign key constraints which results in referencing different columns\nin different tables at the same time.\n\n\nBreaking Change: All \n...ByName\n such as \nTable#columnsByName\n methods are removed, and collections such as \nTable#columns\n return Map instead of array or object.\nMaps return values in order like arrays and they can be queried with \n.has\n method like objects.\n\n\nBreaking Change: \nColumn#uniqueIndexesNoPK\n is renamed as \nColumn#uniqueIndexesNoPk\n.\n\n\nAdded: Optional Lazy loading, cache of lazy loaded parts, invalidation logic of cache.\n\n\nAdded: \npgStructure.serialize\n and \npgStructure.deserialize\n methods.\n\n\nAdded: \npgStructure.save\n and \npgStructure.load\n methods. Load is 10 times faster than querying database. \n\n\nAdded: \nColumn#domainSchema\n\n\nAdded: \nConstraint#matchOption\n, \nConstraint#referencedColumnsBy\n\n\nAdded: \nTable#belongsToManyTablesPk\n, \nTable#m2mRelationsPk\n\n\nDoc updates and changes.\n\n\n\n\n2.0.8 / 2015-12-09\n\n\n\n\nAdded: \nTable#description\n and \nTable#comment\n attributes added to the table object.\n\n\nFixed: Table sql was returning null for table descriptions. \n\n\n\n\n2.0.5 / 2015-12-08\n\n\n\n\nChanged: Code and API cleanup and simplification since alpha releases.\n\n\nChanged: Array and collection object returning attributes now return empty array or empty object if no result found. Previously they returned null. They are usually used in loops, and this change helps getting rid of null checks.\n\n\nRemoved: All methods which are duplicate of attributes. They cause duplicated code and don't add any useful contribution. Same can be achieved using attributes with foreach and better can be achieved with for..of. \n\n\n\n\n2.0.0-alpha.9 / 2015-11-29\n\n\n\n\nFixed: One to many and many to one relations duplicates.\n\n\n\n\n2.0.0-alpha.8 / 2015-11-29\n\n\n\n\nFixed: Join tables with more than one relations produce warning about non-unique constraint.\n\n\nFixed: referencedTable returns undefined.\n\n\nFixed: Example on README throws exception. Typo corrected. Catch part added.\n\n\nAdded: New tests for fixed bugs.\n\n\n\n\n2.0.0-alpha.5 / 2015-11-19\n\n\n\n\nAdded: Table#relations and Table#getRelations().\n\n\n\n\n2.0.0-alpha.3 / 2015-11-19\n\n\n\n\nFixed: Broken links in documentation.\n\n\n\n\n2.0.0-alpha.2 / 2015-11-17\n\n\n\n\nAdded: Index class is added.\n\n\nFixed: Column#unique was assuming that a column can have only one unique constraint. Now it returns array.\n\n\nFixed: Column#unique was ignoring unique indexes Now it considers unique indexes too.\n\n\nFixed: Many typos in constraint class documentation.\n\n\n\n\n2.0.0-alpha.1 / 2015-11-11\n\n\n\n\n BREAKING CHANGES \n\n\nCompletely rewritten.\n\n\nMethods are converted to read only attributes.\n\n\nNew methods are named as verb such as getColumn().\n\n\nNew classes added: Relation, O2MRelation (one to many), M2ORelation (many to one), M2M Relation (many to many).\n\n\nConstraint features that are technically not available in DB Engine moved from \nConstraint\n class to related \nRelation\n classes.\n\n\nDocumentation updated completely and added clearer examples.\n\n\nSome method names and attributes are more intuitive than previous version.\n\n\n\n\nWhy v2 has incompatible changes?\n\n\nVersion 2 is designed to be more elegant and more intuitive. Methods are changed to read only attributes and new methods\n are easily distinguished from attributes with verb based names such as \ncolumns\n vs \ngetColumns()\n.\n\n\nAdditionally new \nRelation\n classes are added. Some of the features are moved from \nConstraint\n to \nRelation\n,\n because some features are technically not available in DB Engine and those features misrepresent \nConstraint\n.\n\n\nFor example many to many relations are virtual relationships which do not actually exist in database. They are\ntables joined via a third join table.\n\n\n1.11.1 / 2015-06-16\n\n\n\n\nAdded: JSONB support. Contributed by: viniciuspinto (https://github.com/viniciuspinto)\n\n\n\n\n1.11.0 / 2014-12-30\n\n\n\n\nAdded: Constraint.throughForeignKeyConstraintToSelf() method added.\n\n\nAdded: Winston logging.\n\n\nFixed: Many to Many relations has name collisions if join table connects more than one table and one of the tables has more than one connection to join table. Naming of many to many relations changed.\n\n\n\n\n1.10.0 / 2014-12-23\n\n\n\n\nAdded: db.includedSchemas method to get list of requested schemas to be parsed.\n\n\nAdded: db.schemaIncluded method to determine if given schema name is one of the requested schemas to be parsed.\n\n\nFix: If a table has a reference to not included schema, throws exception. Should not include its foreign key.\n\n\nDoc update.\n\n\n\n\n1.9.0 / 2014-12-12\n\n\n\n\nAdded: table.hasManyThrough.throughForeignKeyConstraint method added to constraint class.\n\n\n\n\n1.8.3 / 2014-12-10\n\n\n\n\nFix: Sequelize type length, precision.\n\n\n\n\n1.8.2 / 2014-12-10\n\n\n\n\nFix: Sequelize type date, time etc. has no length property.\n\n\nFix: Sequelize type dateonly added.\n\n\nTests added.\n\n\n\n\n1.8.0 / 2014-12-10\n\n\n\n\nAdded: Shortcut function 'get' added to db, schema and table classes.\n\n\nFix: hasManyThrough does not return foreign keys.\n\n\n\n\n1.7.0 / 2014-12-10\n\n\n\n\nAdded: onDelete and onUpdate added to hasMany and hasManyThrough relations.\n\n\n\n\n1.6.0 / 2014-12-10\n\n\n\n\nDEPRECATED: column.special function. Use column.enumValues instead.\n\n\nAdded: Tests for enum values.\n\n\nAdded: Enum support for column.sequelizeType function.\n\n\nUpdated: Documentation\n\n\n\n\n1.5.1 / 2014-12-04\n\n\n\n\nFix: Test db does not destroyed after tests.\n\n\n\n\n1.5.0 / 2014-12-04\n\n\n\n\nFix: column.default() method returns default value with type cast. From now on yype cast part is stripped.\n\n\nAdded column.defaultWithTypeCast() method for getting default values with type cast part.\n\n\nTests added for default values.\n\n\n\n\n1.4.0 / 2014-11-28\n\n\n\n\nAdded support for user-defined types.\n\n\nAdded column.udType() method to get user defined type name.\n\n\nAdded necessary tests.\n\n\n\n\n1.3.1 / 2014-11-27\n\n\n\n\nAdded history to readme.\n\n\nFix: Major error: Single schema or default 'public' schema databases throw error.\n\n\nFix: Databases without any table throw error.\n\n\nAdded tests of this fixes and table without any column.\n\n\n\n\n1.3.0 / 2014-11-27\n\n\n\n\nParameter validation added to pg-structure main function. This would ease debugging.\n\n\nFix: pg-structure.generate function was throwing error, now it calls its callback with error\nif database connection error occurs.\n\n\n\n\n1.2.0 / 2014-11-26\n\n\n\n\nFix: pg-structure callback does not get error object. Instead error is thrown. Now callback gets error object as its first parameter as expected.\n\n\ndb.schema() function now throws more informative error if referenced schema is not found in db and also not in the options of requested schemas.\n\n\ndb.schemaExist() function added.\n\n\nHistory.md file added. (This file)\n\n\n\n\n1.1.0 / 2014-11-25\n\n\n\n\ntable.foreignKeyConstraintExist() function added.\n\n\n\n\n1.0.0 / 2014-11-25\n\n\n\n\nCompletely rewritten to migrate from plain object to object oriented design.\n\n\ncolumn.sequelizeType() method added. This method gets sequelize compatible type of the column.", 
            "title": "History"
        }, 
        {
            "location": "/history/#history-release-notes", 
            "text": "", 
            "title": "History &amp; Release Notes"
        }, 
        {
            "location": "/history/#3514-2017-03-06", 
            "text": "Fixed: If same constraint name is used more than once in same schema (non-unique constraint name), pg-structure was failing.", 
            "title": "3.5.14 / 2017-03-06"
        }, 
        {
            "location": "/history/#3511-2017-02-21", 
            "text": "Fixed: Column.default() was returning typecast if default value is ''.", 
            "title": "3.5.11 / 2017-02-21"
        }, 
        {
            "location": "/history/#350-2016-05-04", 
            "text": "Added: Relation naming support for CamelCase tables.  Fixed: Default strategy for Many to Many ( m2m ) and Many to One ( m2o ) relations are selected as 'simple' even 'simple' strategy causes conflict. Now complex is selected when there are conflicts between cross types of  o2m  and  m2m .  Added: Relation naming documentation.  Added: Naming strategy test.", 
            "title": "3.5.0 / 2016-05-04"
        }, 
        {
            "location": "/history/#340", 
            "text": "Changed:  table#descriptionData  tag is changed from  [JSON]  to  [pg-structure]  (EXPERIMENTAL) Added:  o2mRelation#generateName() ,  m2oRelation#generateName() ,  m2mRelation#generateName() . Those methods are highly experimental and may be changed or deleted.", 
            "title": "3.4.0"
        }, 
        {
            "location": "/history/#332-2016-02-25", 
            "text": "Fixed: Tables without primary key was throwing exception for  table#primaryKeyColumns .  Fixed:  table#hasManyTables  and  table#belongsToTables  were returning array instead of Set.", 
            "title": "3.3.2 / 2016-02-25"
        }, 
        {
            "location": "/history/#330-2016-02-24", 
            "text": "Added:  table#descriptionData ,  table#commentData ,  column#descriptionData ,  column#commentData ,  constraint#descriptionData ,  constraint#commentData . It is possible to store and access JSON in objects' description.", 
            "title": "3.3.0 / 2016-02-24"
        }, 
        {
            "location": "/history/#320-2016-02-24", 
            "text": "Added: constraint#description ,  constraint#comment .  Updated: Test ERD corrected.", 
            "title": "3.2.0 / 2016-02-24"
        }, 
        {
            "location": "/history/#311-2016-01-30", 
            "text": "Added:  column#referencedColumns .", 
            "title": "3.1.1 / 2016-01-30"
        }, 
        {
            "location": "/history/#310-2016-01-26", 
            "text": "Added:  #array  method is added all Map types to help building arrays in non supporting environments such as nunjucks.", 
            "title": "3.1.0 / 2016-01-26"
        }, 
        {
            "location": "/history/#300-2016-01-16", 
            "text": "Previous versions of pg-structure are designed to be a build time tool. v3 are designed to be a runtime tool. It is refactored to better performance compared to previous versions.\nInternal storage is completely rewritten. Loki DB is excellent product, but it is overkill for this project. pg-structure now uses direct object references for speed up things.\nDB interaction is reduced from 9 SQL queries to 3. Those 3 queries are same queries from previous version. So work of other 6 queries are done by Javascript now.   Breaking Change:  Column#foreignKeyConstraint  is changed to  Column#foreignKeyConstraints ,  Column#referencedColumn  is removed,\nbecause same column may be part of multiple different foreign key constraints which results in referencing different columns\nin different tables at the same time.  Breaking Change: All  ...ByName  such as  Table#columnsByName  methods are removed, and collections such as  Table#columns  return Map instead of array or object.\nMaps return values in order like arrays and they can be queried with  .has  method like objects.  Breaking Change:  Column#uniqueIndexesNoPK  is renamed as  Column#uniqueIndexesNoPk .  Added: Optional Lazy loading, cache of lazy loaded parts, invalidation logic of cache.  Added:  pgStructure.serialize  and  pgStructure.deserialize  methods.  Added:  pgStructure.save  and  pgStructure.load  methods. Load is 10 times faster than querying database.   Added:  Column#domainSchema  Added:  Constraint#matchOption ,  Constraint#referencedColumnsBy  Added:  Table#belongsToManyTablesPk ,  Table#m2mRelationsPk  Doc updates and changes.", 
            "title": "3.0.0 / 2016-01-16"
        }, 
        {
            "location": "/history/#208-2015-12-09", 
            "text": "Added:  Table#description  and  Table#comment  attributes added to the table object.  Fixed: Table sql was returning null for table descriptions.", 
            "title": "2.0.8 / 2015-12-09"
        }, 
        {
            "location": "/history/#205-2015-12-08", 
            "text": "Changed: Code and API cleanup and simplification since alpha releases.  Changed: Array and collection object returning attributes now return empty array or empty object if no result found. Previously they returned null. They are usually used in loops, and this change helps getting rid of null checks.  Removed: All methods which are duplicate of attributes. They cause duplicated code and don't add any useful contribution. Same can be achieved using attributes with foreach and better can be achieved with for..of.", 
            "title": "2.0.5 / 2015-12-08"
        }, 
        {
            "location": "/history/#200-alpha9-2015-11-29", 
            "text": "Fixed: One to many and many to one relations duplicates.", 
            "title": "2.0.0-alpha.9 / 2015-11-29"
        }, 
        {
            "location": "/history/#200-alpha8-2015-11-29", 
            "text": "Fixed: Join tables with more than one relations produce warning about non-unique constraint.  Fixed: referencedTable returns undefined.  Fixed: Example on README throws exception. Typo corrected. Catch part added.  Added: New tests for fixed bugs.", 
            "title": "2.0.0-alpha.8 / 2015-11-29"
        }, 
        {
            "location": "/history/#200-alpha5-2015-11-19", 
            "text": "Added: Table#relations and Table#getRelations().", 
            "title": "2.0.0-alpha.5 / 2015-11-19"
        }, 
        {
            "location": "/history/#200-alpha3-2015-11-19", 
            "text": "Fixed: Broken links in documentation.", 
            "title": "2.0.0-alpha.3 / 2015-11-19"
        }, 
        {
            "location": "/history/#200-alpha2-2015-11-17", 
            "text": "Added: Index class is added.  Fixed: Column#unique was assuming that a column can have only one unique constraint. Now it returns array.  Fixed: Column#unique was ignoring unique indexes Now it considers unique indexes too.  Fixed: Many typos in constraint class documentation.", 
            "title": "2.0.0-alpha.2 / 2015-11-17"
        }, 
        {
            "location": "/history/#200-alpha1-2015-11-11", 
            "text": "BREAKING CHANGES   Completely rewritten.  Methods are converted to read only attributes.  New methods are named as verb such as getColumn().  New classes added: Relation, O2MRelation (one to many), M2ORelation (many to one), M2M Relation (many to many).  Constraint features that are technically not available in DB Engine moved from  Constraint  class to related  Relation  classes.  Documentation updated completely and added clearer examples.  Some method names and attributes are more intuitive than previous version.", 
            "title": "2.0.0-alpha.1 / 2015-11-11"
        }, 
        {
            "location": "/history/#why-v2-has-incompatible-changes", 
            "text": "Version 2 is designed to be more elegant and more intuitive. Methods are changed to read only attributes and new methods\n are easily distinguished from attributes with verb based names such as  columns  vs  getColumns() .  Additionally new  Relation  classes are added. Some of the features are moved from  Constraint  to  Relation ,\n because some features are technically not available in DB Engine and those features misrepresent  Constraint .  For example many to many relations are virtual relationships which do not actually exist in database. They are\ntables joined via a third join table.", 
            "title": "Why v2 has incompatible changes?"
        }, 
        {
            "location": "/history/#1111-2015-06-16", 
            "text": "Added: JSONB support. Contributed by: viniciuspinto (https://github.com/viniciuspinto)", 
            "title": "1.11.1 / 2015-06-16"
        }, 
        {
            "location": "/history/#1110-2014-12-30", 
            "text": "Added: Constraint.throughForeignKeyConstraintToSelf() method added.  Added: Winston logging.  Fixed: Many to Many relations has name collisions if join table connects more than one table and one of the tables has more than one connection to join table. Naming of many to many relations changed.", 
            "title": "1.11.0 / 2014-12-30"
        }, 
        {
            "location": "/history/#1100-2014-12-23", 
            "text": "Added: db.includedSchemas method to get list of requested schemas to be parsed.  Added: db.schemaIncluded method to determine if given schema name is one of the requested schemas to be parsed.  Fix: If a table has a reference to not included schema, throws exception. Should not include its foreign key.  Doc update.", 
            "title": "1.10.0 / 2014-12-23"
        }, 
        {
            "location": "/history/#190-2014-12-12", 
            "text": "Added: table.hasManyThrough.throughForeignKeyConstraint method added to constraint class.", 
            "title": "1.9.0 / 2014-12-12"
        }, 
        {
            "location": "/history/#183-2014-12-10", 
            "text": "Fix: Sequelize type length, precision.", 
            "title": "1.8.3 / 2014-12-10"
        }, 
        {
            "location": "/history/#182-2014-12-10", 
            "text": "Fix: Sequelize type date, time etc. has no length property.  Fix: Sequelize type dateonly added.  Tests added.", 
            "title": "1.8.2 / 2014-12-10"
        }, 
        {
            "location": "/history/#180-2014-12-10", 
            "text": "Added: Shortcut function 'get' added to db, schema and table classes.  Fix: hasManyThrough does not return foreign keys.", 
            "title": "1.8.0 / 2014-12-10"
        }, 
        {
            "location": "/history/#170-2014-12-10", 
            "text": "Added: onDelete and onUpdate added to hasMany and hasManyThrough relations.", 
            "title": "1.7.0 / 2014-12-10"
        }, 
        {
            "location": "/history/#160-2014-12-10", 
            "text": "DEPRECATED: column.special function. Use column.enumValues instead.  Added: Tests for enum values.  Added: Enum support for column.sequelizeType function.  Updated: Documentation", 
            "title": "1.6.0 / 2014-12-10"
        }, 
        {
            "location": "/history/#151-2014-12-04", 
            "text": "Fix: Test db does not destroyed after tests.", 
            "title": "1.5.1 / 2014-12-04"
        }, 
        {
            "location": "/history/#150-2014-12-04", 
            "text": "Fix: column.default() method returns default value with type cast. From now on yype cast part is stripped.  Added column.defaultWithTypeCast() method for getting default values with type cast part.  Tests added for default values.", 
            "title": "1.5.0 / 2014-12-04"
        }, 
        {
            "location": "/history/#140-2014-11-28", 
            "text": "Added support for user-defined types.  Added column.udType() method to get user defined type name.  Added necessary tests.", 
            "title": "1.4.0 / 2014-11-28"
        }, 
        {
            "location": "/history/#131-2014-11-27", 
            "text": "Added history to readme.  Fix: Major error: Single schema or default 'public' schema databases throw error.  Fix: Databases without any table throw error.  Added tests of this fixes and table without any column.", 
            "title": "1.3.1 / 2014-11-27"
        }, 
        {
            "location": "/history/#130-2014-11-27", 
            "text": "Parameter validation added to pg-structure main function. This would ease debugging.  Fix: pg-structure.generate function was throwing error, now it calls its callback with error\nif database connection error occurs.", 
            "title": "1.3.0 / 2014-11-27"
        }, 
        {
            "location": "/history/#120-2014-11-26", 
            "text": "Fix: pg-structure callback does not get error object. Instead error is thrown. Now callback gets error object as its first parameter as expected.  db.schema() function now throws more informative error if referenced schema is not found in db and also not in the options of requested schemas.  db.schemaExist() function added.  History.md file added. (This file)", 
            "title": "1.2.0 / 2014-11-26"
        }, 
        {
            "location": "/history/#110-2014-11-25", 
            "text": "table.foreignKeyConstraintExist() function added.", 
            "title": "1.1.0 / 2014-11-25"
        }, 
        {
            "location": "/history/#100-2014-11-25", 
            "text": "Completely rewritten to migrate from plain object to object oriented design.  column.sequelizeType() method added. This method gets sequelize compatible type of the column.", 
            "title": "1.0.0 / 2014-11-25"
        }, 
        {
            "location": "/license/", 
            "text": "LICENSE\n\n\nThe MIT License (MIT)\n\n\nCopyright (c) 2015 \u00d6z\u00fcm Eldo\u011fan\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/license/#license", 
            "text": "The MIT License (MIT)  Copyright (c) 2015 \u00d6z\u00fcm Eldo\u011fan  Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", 
            "title": "LICENSE"
        }, 
        {
            "location": "/report/", 
            "text": "lab\n tests and coverage report can be seen \nhere\n.", 
            "title": "Test & Coverage Report"
        }, 
        {
            "location": "/relation-names/", 
            "text": "Relation Names\n\n\nActually database systems does not have relations. They have foreign key constraints. Relation is a concept to describe relationships between tables based on foreign key constraints. \npg-structure\n provides \nO2MRelation\n, \nM2MRelation\n and \nM2ORelation\n classes relations.\n\n\nSince relations are not real objects defined in database systems, they do not have names. Relation names used in ORM systems should generated somehow. Naming is already very complex mental process and there are multiple methods and preferences to name relations. \npg-structure\n provides more than one strategy to generate names for different preferences and to reduce chance of conflicting names. They aren't perfect, but at least does the job for most of the time.\n\n\nStrategies\n\n\nTo name relations \npg-structure\n provides strategies below. All strategies tries to guess inflection of table names such as snake_case or CamelCase with a simple test. If first letter is capital, then it is assumed CamelCase, snake_case otherwise. Generated names use guessed inflection.\n\n\nWhen \ngenerateName()\n method is called without any strategies, \npg-structure\n chooses simple strategy. If there are more than one relation between same tables, additional relations are named using complex strategy to prevent conflicts.\n\n\nBelow is a database schema as an example:\n\n\n size -------------------\n id (PK)                |  ---------------------------\n line_item \n------------ cart\n name                   |  |                            product_id (PFK)        id (PK)\n                        |  |                            cart_id    (PFK)        name\n                        ^  |\n color -------------\n product \n------------- vendor\n id (PK)              id        (PK)         id (PK)\n name                 name                   name\n                      color_id  (FK)\n                      size_id   (FK)\n                      vendor_id (FK)\n\n\n\n\n\nBelow is the same schema as image:\n \n\n\nO2M examples are given for:\n\n\nproduct ---\n line_item\n (i.e. \nproduct.o2mRelations.values()[0].generateName('simple')\n).\n\n\nM2O examples are given for:\n\n\nline_item \n--- product\n (i.e. \nlineItem.m2oRelations.values()[0].generateName('simple')\n).\n\n\nM2M examples are given for:\n\n\nproduct ---\n line_item \n--- cart\n (i.e. \nproduct.m2mRelations.values()[0].generateName('simple')\n).\n\n\n\n\n\n\n\n\nRelation\n\n\nForm\n\n\nStrategy\n\n\nDescription\n\n\nExample\n\n\n\n\n\n\n\n\n\n\nO2M\n\n\nsimple\n\n\nPlural\n\n\nTarget table name.\n\n\nline_items\n\n\n\n\n\n\nO2M\n\n\ncomplex\n\n\nPlural\n\n\nConstraint name, but source table name stripped from beginning.\n\n\nsold_items\n\n\n\n\n\n\nM2O\n\n\nsimple\n\n\nSingular\n\n\nTarget table name.\n\n\nproduct\n\n\n\n\n\n\nM2O\n\n\ncomplex\n\n\nSingular\n\n\nFirst foreign key column name. If 'id' string is present, it is stripped, otherwise 'related' prefix added.\n\n\nproduct\n\n\n\n\n\n\nM2M\n\n\nsimple\n\n\nPlural\n\n\nTarget table name.\n\n\ncarts\n\n\n\n\n\n\nM2M\n\n\ncomplex\n\n\nPlural\n\n\nJoin Table Name + Foreign Key to Target Table. If 'id' string is present, it is stripped, otherwise 'related' prefix added.\n\n\nline_item_carts\n\n\n\n\n\n\n\n\nOverriding\n\n\nEven using complex strategy, it is sometimes impossible to generate unique names. In that case it is possible to override generated names by providing clues to \npg-structure\n in database.\n\n\nUsing Constraint Description Data (!EXPERIMENTAL)\n\n\nYou can use constraint's description in PostgreSQL. Description data is fetched from constraint description. In short, you can put JSON data between \n[pg-structure]\n and \n[/pg-structure]\n tags in constraint description.\n\n\n(\nSee Description Data in Concepts\n). It is a non-strict JSON data. \npg-structure\n uses given names in description data.\n\n\nExample:\n\n\n[pg-structure]\n{\n    name: {\n        m2m: my_custom_name\n    }\n}\n[/pg-structure]\n\n\n\n\n\n\n\n\n\n\nRelation\n\n\nJSON Key\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nO2M\n\n\nname.hasMany\n or \nname.o2m\n\n\nUsed as it is\n\n\n\n\n\n\nM2O\n\n\nname.belongsTo\n or \nname.m2o\n\n\nUsed as it is\n\n\n\n\n\n\nM2M\n\n\nname.belongsToMany\n or \nname.m2m\n\n\nUsed as: Given String + Target Table Name\n\n\n\n\n\n\n\n\nUsing Constraint Name as CSV (!EXPERIMENTAL)\n\n\nYou can also name your constraints in database as a CSV. If constraint name includes comma, \npg-structure\n assumes it is CSV value to provide clue for relation names.\n\n\n\n\n\n\n\n\nCSV\n\n\nDescription\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\n1\n\n\nOne to many relation name\n\n\nUsed as it is\n\n\n\n\n\n\n2\n\n\nMany to one relation name\n\n\nUsed as it is\n\n\n\n\n\n\n3\n\n\nPrefix for many to many relations\n\n\nUsed as: Given String + Target Table Name\n\n\n\n\n\n\n\n\nExample:\n\n\n         sold_items, item, sku                cart_goods, basket, bag\nproduct ------------------------\n line_item \n------------------------- cart\n\n\n\n\n\n\n\n\n\n\n\nCSV\n\n\nFrom\n\n\nTo\n\n\nType\n\n\nName\n\n\n\n\n\n\n\n\n\n\n1\n\n\nproduct\n\n\nline_item\n\n\nO2M\n\n\nsold_items\n\n\n\n\n\n\n2\n\n\nline_item\n\n\nproduct\n\n\nM2O\n\n\nitem\n\n\n\n\n\n\n3\n\n\nproduct\n\n\ncart\n\n\nM2M\n\n\nsku_carts\n\n\n\n\n\n\n1\n\n\ncart\n\n\nline_item\n\n\nO2M\n\n\ncart_goods\n\n\n\n\n\n\n2\n\n\nline_item\n\n\ncart\n\n\nM2O\n\n\nbasket\n\n\n\n\n\n\n3\n\n\ncart\n\n\nproduct\n\n\nM2M\n\n\nbag_products\n\n\n\n\n\n\n\n\nPriority\n\n\nRelation naming function prioritizes different methods as follows:\n\n\n\n\n\n\n\n\n#\n\n\nMethod\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\n1\n\n\nStrategy from function parameter\n\n\nIf parameter is given such as \nrel.generateName('simple')\n, uses given strategy.\n\n\n\n\n\n\n2\n\n\nConstraint Name CSV\n\n\nPRO:\n May easy to use in ERD tools. \nCON:\n Invasive, seen in DB error messages.\n\n\n\n\n\n\n3\n\n\nConstraint Description Data\n\n\nPRO:\n Non invasive. \nCON:\n One more step in ERD tools.\n\n\n\n\n\n\n4\n\n\nSimple Stratgey\n\n\nIf there is no previous relation between same tables.\n\n\n\n\n\n\n5\n\n\nComplex Strategy\n\n\nLast resort.\n\n\n\n\n\n\n\n\nModule's Author's Practices\n\n\nUse \ngenerateName()\n without parameters, and if you don't like generated names for a specific relation, use description data in that constraint's description.\n\n\nThe reason of preferring description data over constraint name is that when foreign key violation occurs, PostgreSQL error messages contains constraint names and long CSV names may be confusing.", 
            "title": "Relation Names"
        }, 
        {
            "location": "/relation-names/#relation-names", 
            "text": "Actually database systems does not have relations. They have foreign key constraints. Relation is a concept to describe relationships between tables based on foreign key constraints.  pg-structure  provides  O2MRelation ,  M2MRelation  and  M2ORelation  classes relations.  Since relations are not real objects defined in database systems, they do not have names. Relation names used in ORM systems should generated somehow. Naming is already very complex mental process and there are multiple methods and preferences to name relations.  pg-structure  provides more than one strategy to generate names for different preferences and to reduce chance of conflicting names. They aren't perfect, but at least does the job for most of the time.", 
            "title": "Relation Names"
        }, 
        {
            "location": "/relation-names/#strategies", 
            "text": "To name relations  pg-structure  provides strategies below. All strategies tries to guess inflection of table names such as snake_case or CamelCase with a simple test. If first letter is capital, then it is assumed CamelCase, snake_case otherwise. Generated names use guessed inflection.  When  generateName()  method is called without any strategies,  pg-structure  chooses simple strategy. If there are more than one relation between same tables, additional relations are named using complex strategy to prevent conflicts.  Below is a database schema as an example:   size -------------------\n id (PK)                |  ---------------------------  line_item  ------------ cart\n name                   |  |                            product_id (PFK)        id (PK)\n                        |  |                            cart_id    (PFK)        name\n                        ^  |\n color -------------  product  ------------- vendor\n id (PK)              id        (PK)         id (PK)\n name                 name                   name\n                      color_id  (FK)\n                      size_id   (FK)\n                      vendor_id (FK)  Below is the same schema as image:\n   O2M examples are given for:  product ---  line_item  (i.e.  product.o2mRelations.values()[0].generateName('simple') ).  M2O examples are given for:  line_item  --- product  (i.e.  lineItem.m2oRelations.values()[0].generateName('simple') ).  M2M examples are given for:  product ---  line_item  --- cart  (i.e.  product.m2mRelations.values()[0].generateName('simple') ).     Relation  Form  Strategy  Description  Example      O2M  simple  Plural  Target table name.  line_items    O2M  complex  Plural  Constraint name, but source table name stripped from beginning.  sold_items    M2O  simple  Singular  Target table name.  product    M2O  complex  Singular  First foreign key column name. If 'id' string is present, it is stripped, otherwise 'related' prefix added.  product    M2M  simple  Plural  Target table name.  carts    M2M  complex  Plural  Join Table Name + Foreign Key to Target Table. If 'id' string is present, it is stripped, otherwise 'related' prefix added.  line_item_carts", 
            "title": "Strategies"
        }, 
        {
            "location": "/relation-names/#overriding", 
            "text": "Even using complex strategy, it is sometimes impossible to generate unique names. In that case it is possible to override generated names by providing clues to  pg-structure  in database.", 
            "title": "Overriding"
        }, 
        {
            "location": "/relation-names/#using-constraint-description-data-experimental", 
            "text": "You can use constraint's description in PostgreSQL. Description data is fetched from constraint description. In short, you can put JSON data between  [pg-structure]  and  [/pg-structure]  tags in constraint description.  ( See Description Data in Concepts ). It is a non-strict JSON data.  pg-structure  uses given names in description data.  Example:  [pg-structure]\n{\n    name: {\n        m2m: my_custom_name\n    }\n}\n[/pg-structure]     Relation  JSON Key  Notes      O2M  name.hasMany  or  name.o2m  Used as it is    M2O  name.belongsTo  or  name.m2o  Used as it is    M2M  name.belongsToMany  or  name.m2m  Used as: Given String + Target Table Name", 
            "title": "Using Constraint Description Data (!EXPERIMENTAL)"
        }, 
        {
            "location": "/relation-names/#using-constraint-name-as-csv-experimental", 
            "text": "You can also name your constraints in database as a CSV. If constraint name includes comma,  pg-structure  assumes it is CSV value to provide clue for relation names.     CSV  Description  Notes      1  One to many relation name  Used as it is    2  Many to one relation name  Used as it is    3  Prefix for many to many relations  Used as: Given String + Target Table Name     Example:           sold_items, item, sku                cart_goods, basket, bag\nproduct ------------------------  line_item  ------------------------- cart     CSV  From  To  Type  Name      1  product  line_item  O2M  sold_items    2  line_item  product  M2O  item    3  product  cart  M2M  sku_carts    1  cart  line_item  O2M  cart_goods    2  line_item  cart  M2O  basket    3  cart  product  M2M  bag_products", 
            "title": "Using Constraint Name as CSV (!EXPERIMENTAL)"
        }, 
        {
            "location": "/relation-names/#priority", 
            "text": "Relation naming function prioritizes different methods as follows:     #  Method  Notes      1  Strategy from function parameter  If parameter is given such as  rel.generateName('simple') , uses given strategy.    2  Constraint Name CSV  PRO:  May easy to use in ERD tools.  CON:  Invasive, seen in DB error messages.    3  Constraint Description Data  PRO:  Non invasive.  CON:  One more step in ERD tools.    4  Simple Stratgey  If there is no previous relation between same tables.    5  Complex Strategy  Last resort.", 
            "title": "Priority"
        }, 
        {
            "location": "/relation-names/#modules-authors-practices", 
            "text": "Use  generateName()  without parameters, and if you don't like generated names for a specific relation, use description data in that constraint's description.  The reason of preferring description data over constraint name is that when foreign key violation occurs, PostgreSQL error messages contains constraint names and long CSV names may be confusing.", 
            "title": "Module's Author's Practices"
        }, 
        {
            "location": "/api/Column/", 
            "text": "Column\n\n\nKind\n: global class  \n\n\n\n\nColumn\n\n\nnew Column(args)\n\n\n.allowNull\n : \nboolean\n\n\n.arrayDimension\n : \nnumber\n\n\n.arrayType\n : \nstring\n \n \nnull\n\n\n.comment\n : \nstring\n \n \nnull\n\n\n.commentData\n : \nObject\n\n\n.db\n : \nDb\n\n\n.default\n : \nstring\n \n \nnull\n\n\n.defaultWithTypeCast\n : \nstring\n \n \nnull\n\n\n.description\n : \nstring\n \n \nnull\n\n\n.descriptionData\n : \nObject\n\n\n.domainName\n : \nstring\n \n \nnull\n\n\n.domainFullName\n : \nstring\n \n \nnull\n\n\n.domainFullCatalogName\n : \nstring\n \n \nnull\n\n\n.domainSchema\n : \nstring\n \n \nnull\n\n\n.enumLabels\n : \nArray.\nstring\n \n \nnull\n\n\n.enumValues\n : \nArray.\nstring\n \n \nnull\n\n\n.foreignKeyConstraints\n : \nMap.\nConstraint\n\n\n.fullName\n : \nstring\n\n\n.fullCatalogName\n : \nstring\n\n\n.indexes\n : \nMap.\nIndex\n\n\n.isAutoIncrement\n : \nboolean\n\n\n.isSerial\n : \nboolean\n\n\n.isForeignKey\n : \nboolean\n\n\n.isPrimaryKey\n : \nboolean\n\n\n.length\n : \nnumber\n \n \nnull\n\n\n.name\n : \nstring\n\n\n.notNull\n : \nboolean\n\n\n.parent\n : \nTable\n\n\n.precision\n : \nnumber\n \n \nnull\n\n\n.referencedColumns\n : \nSet.\nColumn\n\n\n.scale\n : \nnumber\n \n \nnull\n\n\n.schema\n : \nSchema\n\n\n.type\n : \npostgreSQLDataType\n\n\n.table\n : \nTable\n\n\n.userDefinedType\n : \npostgreSQLDataType\n \n \nnull\n\n\n.uniqueIndexesNoPk\n : \nMap.\nIndex\n\n\n.uniqueIndexes\n : \nMap.\nIndex\n\n\n\n\n\n\n\n\n\n\nnew Column(args)\n\n\nConstructor function. You don't need to call constructor manually. pg-structure handles this.\n\n\nReturns\n: \nColumn\n - - \nColumn\n instance.  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nargs\n\n\nObject\n\n\nAttributes of the \nColumn\n instance to be created.\n\n\n\n\n\n\n\n\n\n\ncolumn.allowNull : \nboolean\n\n\ntrue\n if column is allowed to contain null values; otherwise \nfalse\n.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: \nnotNull\n.\n\n\n\n\ncolumn.arrayDimension : \nnumber\n\n\nNumber of dimensions, if the column is an array type; otherwise 0.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.arrayType : \nstring\n \n \nnull\n\n\nIf this column is an array, data type of the array. If column is not an array equals \nnull\n.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.comment : \nstring\n \n \nnull\n\n\nComment about column.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ndescription\n\n\n\n\ncolumn.commentData : \nObject\n\n\nJS Object extracted from column description. Object is expected as JSON data between \n[JSON]\n and \n[/JSON]\n\ntags in description. Tags are case-insensitive.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ndescriptionData\n\n\nExample\n  \n\n\nlet description = column.comment;            // -\n 'This column holds name of account. [JSON]{ \nextraData\n: 2 }[/PGEN]'\nlet extra = column.commentData;              // -\n { extraData: 2 }\nconsole.log(column.commentData.extraData);   // -\n 2\n\n\n\n\n\n\ncolumn.db : \nDb\n\n\nDb\n this table belongs to.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.default : \nstring\n \n \nnull\n\n\nDefault value of the column without typecast. Default values includes single quotes except sql functions and numeric values.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: \ndefaultWithTypeCast\n for default values with typecast as returned by PostgreSQL\n\n\nExample\n  \n\n\nvar column = db('crm').schema('public').table('contact').column('name');\nvar type = column.default;           // \n'George'\n\ntype = age.default;                  // 20\ntype = created_at.default;           // \nnow()\n\ntype = column.defaultWithTypeCast;   // \n'George'::character varying\n\n\n\n\n\n\n\ncolumn.defaultWithTypeCast : \nstring\n \n \nnull\n\n\nDefault expression of the column with typecast. PostgreSQL returns default values with typecast.\nDefault values includes single quotes except sql functions and numeric values. Also sql functions and numeric values\ndo not contain type cast.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: \ndefault\n for accessing default values without typecast.\n\n\nExample\n  \n\n\nvar column = db('crm').schema('public').table('contact').column('name');\nvar type = column.defaultWithTypeCast;   // \n'George'::character varying\n\ntype = age.defaultWithTypeCast;          // 20\ntype = created_at.defaultWithTypeCast;   // \nnow()\n\ntype = column.default;                   // \n'George'\n\n\n\n\n\n\n\ncolumn.description : \nstring\n \n \nnull\n\n\nComment about column.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ncomment\n\n\n\n\ncolumn.descriptionData : \nObject\n\n\nJS Object extracted from column description. Object is expected as JSON data between \n[JSON]\n and \n[/JSON]\n\ntags in description. Tags are case-insensitive.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ncommentData\n\n\nExample\n  \n\n\nlet description = column.description;            // -\n 'This column holds name of account. [JSON]{ \nextraData\n: 2 }[/PGEN]'\nlet extra = column.descriptionData;              // -\n { extraData: 2 }\nconsole.log(column.descriptionData.extraData);   // -\n 2\n\n\n\n\n\n\ncolumn.domainName : \nstring\n \n \nnull\n\n\nIf column data type is a domain, this equals domain name without domain schema. Otherwise null.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: \ndomainFullName\n \ndomainFullCatalogName\n.\n\n\nExample\n  \n\n\nvar domainName = column.domainName; // i.e. 'phone_number'\n\n\n\n\n\n\ncolumn.domainFullName : \nstring\n \n \nnull\n\n\nIf column data type is a domain, this equals domain name including domain schema. Otherwise null.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: \ndomainName\n.\n\n\nExample\n  \n\n\nvar domainName = column.domainFullName; // i.e. 'public.phone_number'\n\n\n\n\n\n\ncolumn.domainFullCatalogName : \nstring\n \n \nnull\n\n\nIf column data type is a domain, this equals domain name including domain schema. Otherwise null.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: \ndomainName\n.\n\n\nExample\n  \n\n\nvar domainName = column.domainFullName; // i.e. 'public.phone_number'\n\n\n\n\n\n\ncolumn.domainSchema : \nstring\n \n \nnull\n\n\nIf column data type is a domain, this equals domain schema name. Otherwise null.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: \ndomainFullName\n.\n\n\nExample\n  \n\n\nvar domainName = column.domainSchema; // i.e. 'public'\n\n\n\n\n\n\ncolumn.enumLabels : \nArray.\nstring\n \n \nnull\n\n\nArray of the textual labels for enum values column may contain. If column is not an enum, then this\nequals \nundefined\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: Aliases \nenumValues\n\n\n\n\ncolumn.enumValues : \nArray.\nstring\n \n \nnull\n\n\nArray of the textual labels for enum values column may contain. If column is not an enum, then this\nequals \nundefined\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: Aliases \nenumLabels\n\n\n\n\ncolumn.foreignKeyConstraints : \nMap.\nConstraint\n\n\nMap\n of foreign key constraints of the column, if column is part of one or more foreign key constraint.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.fullName : \nstring\n\n\nFull name of the \nColumn\n with (.) notation.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nvar fullName = column.fullName; // public.account.id\n\n\n\n\n\n\ncolumn.fullCatalogName : \nstring\n\n\nFull name of the \nColumn\n with (.) notation including catalog name.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nvar fullName = table.fullCatalogName; // crm.public.account.id\n\n\n\n\n\n\ncolumn.indexes : \nMap.\nIndex\n\n\nMap\n of \nindexes\n, which column is part of.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.isAutoIncrement : \nboolean\n\n\ntrue\n if this column has an auto incremented (\nnextval()\n) default value or defined one of \nserial\n\ntypes.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: Aliases \nisSerial\n\n\n\n\ncolumn.isSerial : \nboolean\n\n\ntrue\n if this column has an auto incremented (\nnextval()\n) default value or defined one of \nserial\n\ntypes.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: Aliases \nisAutoIncrement\n\n\n\n\ncolumn.isForeignKey : \nboolean\n\n\ntrue\n if this column is a foreign key or part of a foreign key constraint; otherwise \nfalse\n.\nPlease note that a foreign key may contain more than one column.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.isPrimaryKey : \nboolean\n\n\ntrue\n if this column is a primary key or part of a primary key constraint; otherwise \nfalse\n.\nPlease note that a primary key may contain more than one column.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.length : \nnumber\n \n \nnull\n\n\nLength of the column.\n\n For data type identified as a character or bit string type, this is the declared\nmaximum length. If column is an array, same rule applies data type of the array.\n\n For character arrays or bit string type arrays, this is the declared maximum length of the array's data type.\n\n For arrays atttypmod records type-specific data supplied at table creation time (for example, the maximum length\nof a varchar column). It is passed to type-specific input functions and length coercion functions.\n\n This value is \nundefined\n for all other data types or if no maximum length was declared.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.name : \nstring\n\n\nName of the column.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.notNull : \nboolean\n\n\ntrue\n if column is \nnot allowed\n to contain null values; otherwise \nfalse\n.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: \nallowNull\n\n\n\n\ncolumn.parent : \nTable\n\n\nTable\n this column belongs to.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ntable\n\n\nExample\n  \n\n\nvar table = column.parent; // Table instance\n\n\n\n\n\n\ncolumn.precision : \nnumber\n \n \nnull\n\n\n\n\nIf data type identifies a numeric type, this contains the (declared or implicit) precision of\nthe type for this column. The precision indicates the number of significant digits.\n\n\nIf data type identifies a date, time, timestamp, or interval type, this column contains the (declared or implicit)\nfractional seconds precision of the type for this attribute, that is, the number of decimal digits maintained\nfollowing the decimal point in the seconds value.\n\n\nIf data type is an array. Same rules apply for the data type of the array, and this value would become precision\nof the data type of the array.\n\n\nFor all other data types, this is \nundefined\n.\n\n\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.referencedColumns : \nSet.\nColumn\n\n\nAll referenced columns in all foreign key constraints by this column.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.scale : \nnumber\n \n \nnull\n\n\n\n\nIf data type identifies an exact numeric type, this contains the (declared or implicit) scale\nof the type for this attribute. The scale indicates the number of significant digits to the right of the decimal point.\n\n\nIf data type is an array. Same rule applies for the data type of the array, and this value would become scale\nof the data type of the array.\n\n\nFor all other data types, this is \nundefined\n.\n\n\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.schema : \nSchema\n\n\nSchema\n this column belongs to.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.type : \npostgreSQLDataType\n\n\nData type of the column.\n\n For built-in types this is name of type.\n\n \nARRAY\n, for arrays, and type of array can be found via \narrayType\n.\n\n \nUSER-DEFINED\n for user defined types, and type of it can be found via \nuserDefinedType\n.\n\n For domain types this is not domain name, but underlying base type of that domain. Use \ndomainName\n or \ndomainFullName\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n\n\n\n\nuserDefinedType\n\n\ndomainName\n and \ndomainFullName\n\n\n\n\n\n\ncolumn.table : \nTable\n\n\nTable\n this column belongs to.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: Aliases \nparent\n\n\nExample\n  \n\n\nvar table = column.table; // Table instance\n\n\n\n\n\n\ncolumn.userDefinedType : \npostgreSQLDataType\n \n \nnull\n\n\nIf type of column is user defined such as composite, enumerated, this is the data type of the underlying type.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\n\n\ncolumn.uniqueIndexesNoPk : \nMap.\nIndex\n\n\nMap\n of unique \nindexes\n, which column is part of. Excludes primary key indexes. PostgreSQL already creates a unique index for unique\n\nconstraints\n. So there is no need to look for unique constraints which will result duplicates.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: \nuniqueIndexes\n for all unique indexes including primary key indexes.\n\n\n\n\ncolumn.uniqueIndexes : \nMap.\nIndex\n\n\nMap\n of unique \nindexes\n, which column is part of. PostgreSQL already creates a unique index for unique\n\nconstraints\n. So there is no need to look for unique constraints which will result duplicates.\n\n\nKind\n: instance property of \nColumn\n\n\nRead only\n: true\n\n\nSee\n: \nuniqueIndexesNoPK\n for unique indexes excluding primary key indexes.", 
            "title": "Column"
        }, 
        {
            "location": "/api/Column/#column", 
            "text": "Kind : global class     Column  new Column(args)  .allowNull  :  boolean  .arrayDimension  :  number  .arrayType  :  string     null  .comment  :  string     null  .commentData  :  Object  .db  :  Db  .default  :  string     null  .defaultWithTypeCast  :  string     null  .description  :  string     null  .descriptionData  :  Object  .domainName  :  string     null  .domainFullName  :  string     null  .domainFullCatalogName  :  string     null  .domainSchema  :  string     null  .enumLabels  :  Array. string     null  .enumValues  :  Array. string     null  .foreignKeyConstraints  :  Map. Constraint  .fullName  :  string  .fullCatalogName  :  string  .indexes  :  Map. Index  .isAutoIncrement  :  boolean  .isSerial  :  boolean  .isForeignKey  :  boolean  .isPrimaryKey  :  boolean  .length  :  number     null  .name  :  string  .notNull  :  boolean  .parent  :  Table  .precision  :  number     null  .referencedColumns  :  Set. Column  .scale  :  number     null  .schema  :  Schema  .type  :  postgreSQLDataType  .table  :  Table  .userDefinedType  :  postgreSQLDataType     null  .uniqueIndexesNoPk  :  Map. Index  .uniqueIndexes  :  Map. Index", 
            "title": "Column"
        }, 
        {
            "location": "/api/Column/#new-columnargs", 
            "text": "Constructor function. You don't need to call constructor manually. pg-structure handles this.  Returns :  Column  - -  Column  instance.       Param  Type  Description      args  Object  Attributes of the  Column  instance to be created.", 
            "title": "new Column(args)"
        }, 
        {
            "location": "/api/Column/#columnallownull-boolean", 
            "text": "true  if column is allowed to contain null values; otherwise  false .  Kind : instance property of  Column  Read only : true  See :  notNull .", 
            "title": "column.allowNull : boolean"
        }, 
        {
            "location": "/api/Column/#columnarraydimension-number", 
            "text": "Number of dimensions, if the column is an array type; otherwise 0.  Kind : instance property of  Column  Read only : true", 
            "title": "column.arrayDimension : number"
        }, 
        {
            "location": "/api/Column/#columnarraytype-string-null", 
            "text": "If this column is an array, data type of the array. If column is not an array equals  null .  Kind : instance property of  Column  Read only : true", 
            "title": "column.arrayType : string &#124; null"
        }, 
        {
            "location": "/api/Column/#columncomment-string-null", 
            "text": "Comment about column.  Kind : instance property of  Column  Read only : true  See : Aliases  description", 
            "title": "column.comment : string &#124; null"
        }, 
        {
            "location": "/api/Column/#columncommentdata-object", 
            "text": "JS Object extracted from column description. Object is expected as JSON data between  [JSON]  and  [/JSON] \ntags in description. Tags are case-insensitive.  Kind : instance property of  Column  Read only : true  See : Aliases  descriptionData  Example     let description = column.comment;            // -  'This column holds name of account. [JSON]{  extraData : 2 }[/PGEN]'\nlet extra = column.commentData;              // -  { extraData: 2 }\nconsole.log(column.commentData.extraData);   // -  2", 
            "title": "column.commentData : Object"
        }, 
        {
            "location": "/api/Column/#columndb-db", 
            "text": "Db  this table belongs to.  Kind : instance property of  Column  Read only : true", 
            "title": "column.db : Db"
        }, 
        {
            "location": "/api/Column/#columndefault-string-null", 
            "text": "Default value of the column without typecast. Default values includes single quotes except sql functions and numeric values.  Kind : instance property of  Column  Read only : true  See :  defaultWithTypeCast  for default values with typecast as returned by PostgreSQL  Example     var column = db('crm').schema('public').table('contact').column('name');\nvar type = column.default;           //  'George' \ntype = age.default;                  // 20\ntype = created_at.default;           //  now() \ntype = column.defaultWithTypeCast;   //  'George'::character varying", 
            "title": "column.default : string &#124; null"
        }, 
        {
            "location": "/api/Column/#columndefaultwithtypecast-string-null", 
            "text": "Default expression of the column with typecast. PostgreSQL returns default values with typecast.\nDefault values includes single quotes except sql functions and numeric values. Also sql functions and numeric values\ndo not contain type cast.  Kind : instance property of  Column  Read only : true  See :  default  for accessing default values without typecast.  Example     var column = db('crm').schema('public').table('contact').column('name');\nvar type = column.defaultWithTypeCast;   //  'George'::character varying \ntype = age.defaultWithTypeCast;          // 20\ntype = created_at.defaultWithTypeCast;   //  now() \ntype = column.default;                   //  'George'", 
            "title": "column.defaultWithTypeCast : string &#124; null"
        }, 
        {
            "location": "/api/Column/#columndescription-string-null", 
            "text": "Comment about column.  Kind : instance property of  Column  Read only : true  See : Aliases  comment", 
            "title": "column.description : string &#124; null"
        }, 
        {
            "location": "/api/Column/#columndescriptiondata-object", 
            "text": "JS Object extracted from column description. Object is expected as JSON data between  [JSON]  and  [/JSON] \ntags in description. Tags are case-insensitive.  Kind : instance property of  Column  Read only : true  See : Aliases  commentData  Example     let description = column.description;            // -  'This column holds name of account. [JSON]{  extraData : 2 }[/PGEN]'\nlet extra = column.descriptionData;              // -  { extraData: 2 }\nconsole.log(column.descriptionData.extraData);   // -  2", 
            "title": "column.descriptionData : Object"
        }, 
        {
            "location": "/api/Column/#columndomainname-string-null", 
            "text": "If column data type is a domain, this equals domain name without domain schema. Otherwise null.  Kind : instance property of  Column  Read only : true  See :  domainFullName   domainFullCatalogName .  Example     var domainName = column.domainName; // i.e. 'phone_number'", 
            "title": "column.domainName : string &#124; null"
        }, 
        {
            "location": "/api/Column/#columndomainfullname-string-null", 
            "text": "If column data type is a domain, this equals domain name including domain schema. Otherwise null.  Kind : instance property of  Column  Read only : true  See :  domainName .  Example     var domainName = column.domainFullName; // i.e. 'public.phone_number'", 
            "title": "column.domainFullName : string &#124; null"
        }, 
        {
            "location": "/api/Column/#columndomainfullcatalogname-string-null", 
            "text": "If column data type is a domain, this equals domain name including domain schema. Otherwise null.  Kind : instance property of  Column  Read only : true  See :  domainName .  Example     var domainName = column.domainFullName; // i.e. 'public.phone_number'", 
            "title": "column.domainFullCatalogName : string &#124; null"
        }, 
        {
            "location": "/api/Column/#columndomainschema-string-null", 
            "text": "If column data type is a domain, this equals domain schema name. Otherwise null.  Kind : instance property of  Column  Read only : true  See :  domainFullName .  Example     var domainName = column.domainSchema; // i.e. 'public'", 
            "title": "column.domainSchema : string &#124; null"
        }, 
        {
            "location": "/api/Column/#columnenumlabels-arraystring-null", 
            "text": "Array of the textual labels for enum values column may contain. If column is not an enum, then this\nequals  undefined  Kind : instance property of  Column  Read only : true  See : Aliases  enumValues", 
            "title": "column.enumLabels : Array.&lt;string&gt; &#124; null"
        }, 
        {
            "location": "/api/Column/#columnenumvalues-arraystring-null", 
            "text": "Array of the textual labels for enum values column may contain. If column is not an enum, then this\nequals  undefined  Kind : instance property of  Column  Read only : true  See : Aliases  enumLabels", 
            "title": "column.enumValues : Array.&lt;string&gt; &#124; null"
        }, 
        {
            "location": "/api/Column/#columnforeignkeyconstraints-mapconstraint", 
            "text": "Map  of foreign key constraints of the column, if column is part of one or more foreign key constraint.  Kind : instance property of  Column  Read only : true", 
            "title": "column.foreignKeyConstraints : Map.&lt;Constraint&gt;"
        }, 
        {
            "location": "/api/Column/#columnfullname-string", 
            "text": "Full name of the  Column  with (.) notation.  Kind : instance property of  Column  Read only : true  Example     var fullName = column.fullName; // public.account.id", 
            "title": "column.fullName : string"
        }, 
        {
            "location": "/api/Column/#columnfullcatalogname-string", 
            "text": "Full name of the  Column  with (.) notation including catalog name.  Kind : instance property of  Column  Read only : true  Example     var fullName = table.fullCatalogName; // crm.public.account.id", 
            "title": "column.fullCatalogName : string"
        }, 
        {
            "location": "/api/Column/#columnindexes-mapindex", 
            "text": "Map  of  indexes , which column is part of.  Kind : instance property of  Column  Read only : true", 
            "title": "column.indexes : Map.&lt;Index&gt;"
        }, 
        {
            "location": "/api/Column/#columnisautoincrement-boolean", 
            "text": "true  if this column has an auto incremented ( nextval() ) default value or defined one of  serial \ntypes.  Kind : instance property of  Column  Read only : true  See : Aliases  isSerial", 
            "title": "column.isAutoIncrement : boolean"
        }, 
        {
            "location": "/api/Column/#columnisserial-boolean", 
            "text": "true  if this column has an auto incremented ( nextval() ) default value or defined one of  serial \ntypes.  Kind : instance property of  Column  Read only : true  See : Aliases  isAutoIncrement", 
            "title": "column.isSerial : boolean"
        }, 
        {
            "location": "/api/Column/#columnisforeignkey-boolean", 
            "text": "true  if this column is a foreign key or part of a foreign key constraint; otherwise  false .\nPlease note that a foreign key may contain more than one column.  Kind : instance property of  Column  Read only : true", 
            "title": "column.isForeignKey : boolean"
        }, 
        {
            "location": "/api/Column/#columnisprimarykey-boolean", 
            "text": "true  if this column is a primary key or part of a primary key constraint; otherwise  false .\nPlease note that a primary key may contain more than one column.  Kind : instance property of  Column  Read only : true", 
            "title": "column.isPrimaryKey : boolean"
        }, 
        {
            "location": "/api/Column/#columnlength-number-null", 
            "text": "Length of the column.  For data type identified as a character or bit string type, this is the declared\nmaximum length. If column is an array, same rule applies data type of the array.  For character arrays or bit string type arrays, this is the declared maximum length of the array's data type.  For arrays atttypmod records type-specific data supplied at table creation time (for example, the maximum length\nof a varchar column). It is passed to type-specific input functions and length coercion functions.  This value is  undefined  for all other data types or if no maximum length was declared.  Kind : instance property of  Column  Read only : true", 
            "title": "column.length : number &#124; null"
        }, 
        {
            "location": "/api/Column/#columnname-string", 
            "text": "Name of the column.  Kind : instance property of  Column  Read only : true", 
            "title": "column.name : string"
        }, 
        {
            "location": "/api/Column/#columnnotnull-boolean", 
            "text": "true  if column is  not allowed  to contain null values; otherwise  false .  Kind : instance property of  Column  Read only : true  See :  allowNull", 
            "title": "column.notNull : boolean"
        }, 
        {
            "location": "/api/Column/#columnparent-table", 
            "text": "Table  this column belongs to.  Kind : instance property of  Column  Read only : true  See : Aliases  table  Example     var table = column.parent; // Table instance", 
            "title": "column.parent : Table"
        }, 
        {
            "location": "/api/Column/#columnprecision-number-null", 
            "text": "If data type identifies a numeric type, this contains the (declared or implicit) precision of\nthe type for this column. The precision indicates the number of significant digits.  If data type identifies a date, time, timestamp, or interval type, this column contains the (declared or implicit)\nfractional seconds precision of the type for this attribute, that is, the number of decimal digits maintained\nfollowing the decimal point in the seconds value.  If data type is an array. Same rules apply for the data type of the array, and this value would become precision\nof the data type of the array.  For all other data types, this is  undefined .   Kind : instance property of  Column  Read only : true", 
            "title": "column.precision : number &#124; null"
        }, 
        {
            "location": "/api/Column/#columnreferencedcolumns-setcolumn", 
            "text": "All referenced columns in all foreign key constraints by this column.  Kind : instance property of  Column  Read only : true", 
            "title": "column.referencedColumns : Set.&lt;Column&gt;"
        }, 
        {
            "location": "/api/Column/#columnscale-number-null", 
            "text": "If data type identifies an exact numeric type, this contains the (declared or implicit) scale\nof the type for this attribute. The scale indicates the number of significant digits to the right of the decimal point.  If data type is an array. Same rule applies for the data type of the array, and this value would become scale\nof the data type of the array.  For all other data types, this is  undefined .   Kind : instance property of  Column  Read only : true", 
            "title": "column.scale : number &#124; null"
        }, 
        {
            "location": "/api/Column/#columnschema-schema", 
            "text": "Schema  this column belongs to.  Kind : instance property of  Column  Read only : true", 
            "title": "column.schema : Schema"
        }, 
        {
            "location": "/api/Column/#columntype-postgresqldatatype", 
            "text": "Data type of the column.  For built-in types this is name of type.   ARRAY , for arrays, and type of array can be found via  arrayType .   USER-DEFINED  for user defined types, and type of it can be found via  userDefinedType .  For domain types this is not domain name, but underlying base type of that domain. Use  domainName  or  domainFullName  Kind : instance property of  Column  Read only : true  See   userDefinedType  domainName  and  domainFullName", 
            "title": "column.type : postgreSQLDataType"
        }, 
        {
            "location": "/api/Column/#columntable-table", 
            "text": "Table  this column belongs to.  Kind : instance property of  Column  Read only : true  See : Aliases  parent  Example     var table = column.table; // Table instance", 
            "title": "column.table : Table"
        }, 
        {
            "location": "/api/Column/#columnuserdefinedtype-postgresqldatatype-null", 
            "text": "If type of column is user defined such as composite, enumerated, this is the data type of the underlying type.  Kind : instance property of  Column  Read only : true", 
            "title": "column.userDefinedType : postgreSQLDataType &#124; null"
        }, 
        {
            "location": "/api/Column/#columnuniqueindexesnopk-mapindex", 
            "text": "Map  of unique  indexes , which column is part of. Excludes primary key indexes. PostgreSQL already creates a unique index for unique constraints . So there is no need to look for unique constraints which will result duplicates.  Kind : instance property of  Column  Read only : true  See :  uniqueIndexes  for all unique indexes including primary key indexes.", 
            "title": "column.uniqueIndexesNoPk : Map.&lt;Index&gt;"
        }, 
        {
            "location": "/api/Column/#columnuniqueindexes-mapindex", 
            "text": "Map  of unique  indexes , which column is part of. PostgreSQL already creates a unique index for unique constraints . So there is no need to look for unique constraints which will result duplicates.  Kind : instance property of  Column  Read only : true  See :  uniqueIndexesNoPK  for unique indexes excluding primary key indexes.", 
            "title": "column.uniqueIndexes : Map.&lt;Index&gt;"
        }, 
        {
            "location": "/api/Constraint/", 
            "text": "Constraint\n\n\nClass which represent a constraint. Provides attributes and methods for details of the constraint.\n\n\nNotes for Through Constraints \n\n\nThrough constraints are used for many to many relationships. Actually there isn't such a thing called\n\nmany to many relationship\n or \nthrough constraint\n in the database engine. They are concepts to describe\nrecords which may be related more than one record on both sides. For example an invoice may contain more than product and\na product may related to more than one invoice. Those relationships are solved a so called many to many \njoin table\n.\n\n\nConstraint class supports many to many relationships. Since those constraints are not present in database engine,\nthey are extracted by estimation/interpretation. Many non-join tables in a database could have more than one\nforeign key constraints, and they may not meant to be join tables, but they have still through relationships .\n\n\nBelow is a database schema as an example:\n\n\nsize -------------------\nid (PK)                |  ---------------------------\n line_item \n------------ cart\nname                   |  |                            product_id (PFK)        id (PK)\n                       |  |                            cart_id    (PFK)        name\n                       ^  |\ncolor -------------\n product \n------------- vendor\nid (PK)              id        (PK)         id (PK)\nname                 name                   name\n                     color_id  (FK)\n                     size_id   (FK)\n                     vendor_id (FK)\n\n\n\n\nBelow is the same schema as image:\n\n\n\nProduct table has 3 foreign key constraints. It is obvious that product table is not meant to be a many to many join table.\nHowever product could have been join table for \nsize \n vendor\n, \ncolor \n vendor\n and \nsize \n color\n. As a result size,\ncolor and vendor tables would have many to many \nthrough constraints\n.\n\n\nKind\n: global class  \n\n\n\n\nConstraint\n\n\nnew Constraint(args)\n\n\n.name\n : \nstring\n\n\n.fullName\n : \nstring\n\n\n.fullCatalogName\n : \nstring\n\n\n.type\n : \ncontsraintType\n\n\n.comment\n : \nstring\n\n\n.commentData\n : \nObject\n\n\n.description\n : \nstring\n\n\n.descriptionData\n : \nObject\n\n\n.child\n : \nTable\n\n\n.table\n : \nTable\n\n\n.db\n : \nDb\n\n\n.schema\n : \nSchema\n\n\n.matchOption\n : \nstring\n\n\n.onUpdate\n : \nconstraintRule\n \n \nnull\n\n\n.onDelete\n : \nconstraintRule\n \n \nnull\n\n\n.referencedTable\n : \nTable\n \n \nnull\n\n\n.parent\n : \nTable\n \n \nnull\n\n\n.columns\n : \nMap.\nColumn\n\n\n.referencedColumnsBy\n : \nMap.\nColumn\n\n\n\n\n\n\n\n\n\n\nnew Constraint(args)\n\n\nConstructor function. You don't need to call constructor manually. pg-structure handles this.\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nargs\n\n\nObject\n\n\nAttributes of the \nConstraint\n instance to be created.\n\n\n\n\n\n\nargs.parent\n\n\nTable\n\n\nFor foreign key constraints this is \nTable\n instance this \nconstraint\n refers to. If this is not a foreign key \nconstraint\n this is \nnull\n.\n\n\n\n\n\n\nargs.table\n\n\nTable\n\n\nTable\n instance the Constraint is defined in.\n\n\n\n\n\n\nargs.schemaName\n\n\nstring\n\n\nSchema name of the Constraint.\n\n\n\n\n\n\nargs.name\n\n\nstring\n\n\nName of the Constraint.\n\n\n\n\n\n\nargs.type\n\n\nstring\n\n\nConstraint type.\n\n\n\n\n\n\nargs.description\n\n\nstring\n\n\nDescription of the constraint.\n\n\n\n\n\n\nargs.descriptionData\n\n\nObject\n\n\nExtra data to store in object.\n\n\n\n\n\n\nargs.onUpdate\n\n\nstring\n\n\nUpdate rule of the constraint.\n\n\n\n\n\n\nargs.onDelete\n\n\nstring\n\n\nDelete rule of the constraint.\n\n\n\n\n\n\nargs.matchOption\n\n\nstring\n\n\nMatch option of the constraint.\n\n\n\n\n\n\n\n\n\n\nconstraint.name : \nstring\n\n\nName of the constraint.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\n\n\nconstraint.fullName : \nstring\n\n\nFull name of the \nconstraint\n with (.) notation.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nvar fullName = constraint.fullName; // crm.public\n\n\n\n\n\n\nconstraint.fullCatalogName : \nstring\n\n\nFull name of the \nconstraint\n with (.) notation including catalog name.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nvar fullCatalogName = constraint.fullCatalogName; // crm.public\n\n\n\n\n\n\nconstraint.type : \ncontsraintType\n\n\nConstraint type. One of \nPRIMARY KEY\n, \nFOREIGN KEY\n or \nCHECK\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\n\n\nconstraint.comment : \nstring\n\n\nComment of the Constraint.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ndescription\n\n\n\n\nconstraint.commentData : \nObject\n\n\nJS Object extracted from constraint description. Object is expected as JSON data between \n[JSON]\n and \n[/JSON]\n\ntags in description. Tags are case-insensitive.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ndescriptionData\n\n\nExample\n  \n\n\nlet description = constraint.comment;            // -\n 'This contraint refers contacts. [JSON]{ \nextraData\n: 2 }[/PGEN]'\nlet extra = constraint.commentData;              // -\n { extraData: 2 }\nconsole.log(constraint.commentData.extraData);   // -\n 2\n\n\n\n\n\n\nconstraint.description : \nstring\n\n\nComment of the Constraint.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ncomment\n\n\n\n\nconstraint.descriptionData : \nObject\n\n\nJS Object extracted from constraint description. Object is expected as JSON data between \n[JSON]\n and \n[/JSON]\n\ntags in description. Tags are case-insensitive.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ncommentData\n\n\nExample\n  \n\n\nlet description = constraint.description;            // -\n 'This contraint refers contacts. [JSON]{ \nextraData\n: 2 }[/PGEN]'\nlet extra = constraint.descriptionData;              // -\n { extraData: 2 }\nconsole.log(constraint.descriptionData.extraData);   // -\n 2\n\n\n\n\n\n\nconstraint.child : \nTable\n\n\nChild \ntable\n of this \nconstraint\n.\n\nNote for foreign key constraints:\n Child table is the table which contains foreign key.\nIn \nexample schema\n product is a child table (vendor_id FK) of vendor table.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nvar table = constraint.child;\n\n\n\n\n\n\nconstraint.table : \nTable\n\n\nTable\n which this \nconstraint\n belongs to or defined in. \n\n\nNote for foreign key constraints:\n As usual PostgreSQL defines foreign key constraints in child tables,\nwhere foreign key column is defined, so this is child table for foreign key constraints.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nvar table = constraint.table;\n\n\n\n\n\n\nconstraint.db : \nDb\n\n\nDb\n this \nconstraint\n belongs to.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\n\n\nconstraint.schema : \nSchema\n\n\nSchema\n this \nconstraint\n belongs to.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\n\n\nconstraint.matchOption : \nstring\n\n\nMatch option of \nConstraint\n.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\n\n\nconstraint.onUpdate : \nconstraintRule\n \n \nnull\n\n\nUpdate rule for foreign key \nconstraints\n. One of \nCASCADE\n, \nSET NULL\n, \nSET DEFAULT\n, \nRESTRICT\n, \nNO ACTION\n\nIf this is not a foreign key \nconstraint\n this is \nnull\n.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\n\n\nconstraint.onDelete : \nconstraintRule\n \n \nnull\n\n\nUpdate rule for foreign key \nconstraints\n. One of \nCASCADE\n, \nSET NULL\n, \nSET DEFAULT\n, \nRESTRICT\n, \nNO ACTION\n\nIf this is not a foreign key \nconstraint\n this is \nnull\n.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\n\n\nconstraint.referencedTable : \nTable\n \n \nnull\n\n\nFor foreign key \nconstraints\n this is \nTable\n instance this \nconstraint\n refers to.\nIf this is not a foreign key \nconstraint\n this is \nnull\n.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\nSee\n: Aliases \nparent\n\n\n\n\nconstraint.parent : \nTable\n \n \nnull\n\n\nFor foreign key \nconstraints\n this is \nTable\n instance this \nconstraint\n refers to.\nIf this is not a foreign key \nconstraint\n this is \nnull\n. \n\n\nPlease Note:\n This is not the \nTable\n this constraint belongs to or defined in. Parent applies only to\nforeign key constraints and for foreign key constraints parent means referenced table not the table it is defined in.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\nSee\n\n\n\n\nAliases \nreferencedTable\n\n\nTo get \nTable\n this constraint belongs to or defined in, use \ntable\n.\n\n\n\n\n\n\nconstraint.columns : \nMap.\nColumn\n\n\nFor foreign key constraints, this is \nmap\n of \ncolumns\n restricted by \nconstraint\n, in order their ordinal position\nwithin the constraint key.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true\n\n\n\n\nconstraint.referencedColumnsBy : \nMap.\nColumn\n\n\nFor foreign key constraints, this is \nmap\n of \ncolumns\n referenced by this constraint's columns.\nKeys are referencing column's names, values are referenced columns.\n\n\nKind\n: instance property of \nConstraint\n\n\nRead only\n: true", 
            "title": "Constraint"
        }, 
        {
            "location": "/api/Constraint/#constraint", 
            "text": "Class which represent a constraint. Provides attributes and methods for details of the constraint.", 
            "title": "Constraint"
        }, 
        {
            "location": "/api/Constraint/#notes-for-through-constraints", 
            "text": "Through constraints are used for many to many relationships. Actually there isn't such a thing called many to many relationship  or  through constraint  in the database engine. They are concepts to describe\nrecords which may be related more than one record on both sides. For example an invoice may contain more than product and\na product may related to more than one invoice. Those relationships are solved a so called many to many  join table .  Constraint class supports many to many relationships. Since those constraints are not present in database engine,\nthey are extracted by estimation/interpretation. Many non-join tables in a database could have more than one\nforeign key constraints, and they may not meant to be join tables, but they have still through relationships .  Below is a database schema as an example:  size -------------------\nid (PK)                |  ---------------------------  line_item  ------------ cart\nname                   |  |                            product_id (PFK)        id (PK)\n                       |  |                            cart_id    (PFK)        name\n                       ^  |\ncolor -------------  product  ------------- vendor\nid (PK)              id        (PK)         id (PK)\nname                 name                   name\n                     color_id  (FK)\n                     size_id   (FK)\n                     vendor_id (FK)  Below is the same schema as image:  Product table has 3 foreign key constraints. It is obvious that product table is not meant to be a many to many join table.\nHowever product could have been join table for  size   vendor ,  color   vendor  and  size   color . As a result size,\ncolor and vendor tables would have many to many  through constraints .  Kind : global class     Constraint  new Constraint(args)  .name  :  string  .fullName  :  string  .fullCatalogName  :  string  .type  :  contsraintType  .comment  :  string  .commentData  :  Object  .description  :  string  .descriptionData  :  Object  .child  :  Table  .table  :  Table  .db  :  Db  .schema  :  Schema  .matchOption  :  string  .onUpdate  :  constraintRule     null  .onDelete  :  constraintRule     null  .referencedTable  :  Table     null  .parent  :  Table     null  .columns  :  Map. Column  .referencedColumnsBy  :  Map. Column", 
            "title": "Notes for Through Constraints "
        }, 
        {
            "location": "/api/Constraint/#new-constraintargs", 
            "text": "Constructor function. You don't need to call constructor manually. pg-structure handles this.     Param  Type  Description      args  Object  Attributes of the  Constraint  instance to be created.    args.parent  Table  For foreign key constraints this is  Table  instance this  constraint  refers to. If this is not a foreign key  constraint  this is  null .    args.table  Table  Table  instance the Constraint is defined in.    args.schemaName  string  Schema name of the Constraint.    args.name  string  Name of the Constraint.    args.type  string  Constraint type.    args.description  string  Description of the constraint.    args.descriptionData  Object  Extra data to store in object.    args.onUpdate  string  Update rule of the constraint.    args.onDelete  string  Delete rule of the constraint.    args.matchOption  string  Match option of the constraint.", 
            "title": "new Constraint(args)"
        }, 
        {
            "location": "/api/Constraint/#constraintname-string", 
            "text": "Name of the constraint.  Kind : instance property of  Constraint  Read only : true", 
            "title": "constraint.name : string"
        }, 
        {
            "location": "/api/Constraint/#constraintfullname-string", 
            "text": "Full name of the  constraint  with (.) notation.  Kind : instance property of  Constraint  Read only : true  Example     var fullName = constraint.fullName; // crm.public", 
            "title": "constraint.fullName : string"
        }, 
        {
            "location": "/api/Constraint/#constraintfullcatalogname-string", 
            "text": "Full name of the  constraint  with (.) notation including catalog name.  Kind : instance property of  Constraint  Read only : true  Example     var fullCatalogName = constraint.fullCatalogName; // crm.public", 
            "title": "constraint.fullCatalogName : string"
        }, 
        {
            "location": "/api/Constraint/#constrainttype-contsrainttype", 
            "text": "Constraint type. One of  PRIMARY KEY ,  FOREIGN KEY  or  CHECK  Kind : instance property of  Constraint  Read only : true", 
            "title": "constraint.type : contsraintType"
        }, 
        {
            "location": "/api/Constraint/#constraintcomment-string", 
            "text": "Comment of the Constraint.  Kind : instance property of  Constraint  Read only : true  See : Aliases  description", 
            "title": "constraint.comment : string"
        }, 
        {
            "location": "/api/Constraint/#constraintcommentdata-object", 
            "text": "JS Object extracted from constraint description. Object is expected as JSON data between  [JSON]  and  [/JSON] \ntags in description. Tags are case-insensitive.  Kind : instance property of  Constraint  Read only : true  See : Aliases  descriptionData  Example     let description = constraint.comment;            // -  'This contraint refers contacts. [JSON]{  extraData : 2 }[/PGEN]'\nlet extra = constraint.commentData;              // -  { extraData: 2 }\nconsole.log(constraint.commentData.extraData);   // -  2", 
            "title": "constraint.commentData : Object"
        }, 
        {
            "location": "/api/Constraint/#constraintdescription-string", 
            "text": "Comment of the Constraint.  Kind : instance property of  Constraint  Read only : true  See : Aliases  comment", 
            "title": "constraint.description : string"
        }, 
        {
            "location": "/api/Constraint/#constraintdescriptiondata-object", 
            "text": "JS Object extracted from constraint description. Object is expected as JSON data between  [JSON]  and  [/JSON] \ntags in description. Tags are case-insensitive.  Kind : instance property of  Constraint  Read only : true  See : Aliases  commentData  Example     let description = constraint.description;            // -  'This contraint refers contacts. [JSON]{  extraData : 2 }[/PGEN]'\nlet extra = constraint.descriptionData;              // -  { extraData: 2 }\nconsole.log(constraint.descriptionData.extraData);   // -  2", 
            "title": "constraint.descriptionData : Object"
        }, 
        {
            "location": "/api/Constraint/#constraintchild-table", 
            "text": "Child  table  of this  constraint . Note for foreign key constraints:  Child table is the table which contains foreign key.\nIn  example schema  product is a child table (vendor_id FK) of vendor table.  Kind : instance property of  Constraint  Read only : true  Example     var table = constraint.child;", 
            "title": "constraint.child : Table"
        }, 
        {
            "location": "/api/Constraint/#constrainttable-table", 
            "text": "Table  which this  constraint  belongs to or defined in.   Note for foreign key constraints:  As usual PostgreSQL defines foreign key constraints in child tables,\nwhere foreign key column is defined, so this is child table for foreign key constraints.  Kind : instance property of  Constraint  Read only : true  Example     var table = constraint.table;", 
            "title": "constraint.table : Table"
        }, 
        {
            "location": "/api/Constraint/#constraintdb-db", 
            "text": "Db  this  constraint  belongs to.  Kind : instance property of  Constraint  Read only : true", 
            "title": "constraint.db : Db"
        }, 
        {
            "location": "/api/Constraint/#constraintschema-schema", 
            "text": "Schema  this  constraint  belongs to.  Kind : instance property of  Constraint  Read only : true", 
            "title": "constraint.schema : Schema"
        }, 
        {
            "location": "/api/Constraint/#constraintmatchoption-string", 
            "text": "Match option of  Constraint .  Kind : instance property of  Constraint  Read only : true", 
            "title": "constraint.matchOption : string"
        }, 
        {
            "location": "/api/Constraint/#constraintonupdate-constraintrule-null", 
            "text": "Update rule for foreign key  constraints . One of  CASCADE ,  SET NULL ,  SET DEFAULT ,  RESTRICT ,  NO ACTION \nIf this is not a foreign key  constraint  this is  null .  Kind : instance property of  Constraint  Read only : true", 
            "title": "constraint.onUpdate : constraintRule &#124; null"
        }, 
        {
            "location": "/api/Constraint/#constraintondelete-constraintrule-null", 
            "text": "Update rule for foreign key  constraints . One of  CASCADE ,  SET NULL ,  SET DEFAULT ,  RESTRICT ,  NO ACTION \nIf this is not a foreign key  constraint  this is  null .  Kind : instance property of  Constraint  Read only : true", 
            "title": "constraint.onDelete : constraintRule &#124; null"
        }, 
        {
            "location": "/api/Constraint/#constraintreferencedtable-table-null", 
            "text": "For foreign key  constraints  this is  Table  instance this  constraint  refers to.\nIf this is not a foreign key  constraint  this is  null .  Kind : instance property of  Constraint  Read only : true  See : Aliases  parent", 
            "title": "constraint.referencedTable : Table &#124; null"
        }, 
        {
            "location": "/api/Constraint/#constraintparent-table-null", 
            "text": "For foreign key  constraints  this is  Table  instance this  constraint  refers to.\nIf this is not a foreign key  constraint  this is  null .   Please Note:  This is not the  Table  this constraint belongs to or defined in. Parent applies only to\nforeign key constraints and for foreign key constraints parent means referenced table not the table it is defined in.  Kind : instance property of  Constraint  Read only : true  See   Aliases  referencedTable  To get  Table  this constraint belongs to or defined in, use  table .", 
            "title": "constraint.parent : Table &#124; null"
        }, 
        {
            "location": "/api/Constraint/#constraintcolumns-mapcolumn", 
            "text": "For foreign key constraints, this is  map  of  columns  restricted by  constraint , in order their ordinal position\nwithin the constraint key.  Kind : instance property of  Constraint  Read only : true", 
            "title": "constraint.columns : Map.&lt;Column&gt;"
        }, 
        {
            "location": "/api/Constraint/#constraintreferencedcolumnsby-mapcolumn", 
            "text": "For foreign key constraints, this is  map  of  columns  referenced by this constraint's columns.\nKeys are referencing column's names, values are referenced columns.  Kind : instance property of  Constraint  Read only : true", 
            "title": "constraint.referencedColumnsBy : Map.&lt;Column&gt;"
        }, 
        {
            "location": "/api/Db/", 
            "text": "Db\n\n\nClass which represent a database. Provides attributes and methods for details of the database.\n\n\nKind\n: global class  \n\n\n\n\nDb\n\n\nnew Db(args, options)\n\n\n.name\n : \nstring\n\n\n.fullName\n : \nstring\n\n\n.fullCatalogName\n : \nstring\n\n\n.options\n : \nObject\n\n\n.schemas\n : \nMap.\nSchema\n\n\n.get(path)\n \u21d2 \nSchema\n \n \nTable\n \n \nColumn\n \n \nundefined\n\n\n\n\n\n\n\n\n\n\nnew Db(args, options)\n\n\nConstructor function. You don't need to call constructor manually. pg-structure handles this.\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nargs\n\n\nObject\n\n\n\n\nAttributes of the \nDatabase\n instance to be created.\n\n\n\n\n\n\nargs.name\n\n\nObject\n\n\n\n\nName of the \nDb\n instance.\n\n\n\n\n\n\noptions\n\n\nObject\n\n\n\n\nOptions to modify behaviour of classes.\n\n\n\n\n\n\n[options.cache]\n\n\nboolean\n\n\ntrue\n\n\nUse cache to memoize calculated results.\n\n\n\n\n\n\n\n\n\n\ndb.name : \nstring\n\n\nName of the \nDatabase\n.\n\n\nKind\n: instance property of \nDb\n\n\nRead only\n: true\n\n\n\n\ndb.fullName : \nstring\n\n\nFull name of the \nDatabase\n with (.) notation. Since database does not have a parent this equals database name.\n\n\nKind\n: instance property of \nDb\n\n\nRead only\n: true\n\n\n\n\ndb.fullCatalogName : \nstring\n\n\nFull name of the \nDatabase\n with (.) notation including catalog name. Since database does not have a parent this equals database name.\n\n\nKind\n: instance property of \nDb\n\n\nRead only\n: true\n\n\n\n\ndb.options : \nObject\n\n\nOptions passed to during initialization.\n\n\nKind\n: instance property of \nDb\n\n\nRead only\n: true\n\n\n\n\ndb.schemas : \nMap.\nSchema\n\n\nAll \nSchema\n instances in the database as a \nMap\n. Schemas are ordered by their name.\n\n\nKind\n: instance property of \nDb\n\n\nRead only\n: true\n\n\nSee\n: \nMap\n\n\nExample\n  \n\n\nlet isAvailable  = db.schemas.has('another_schema');\nlet schemaNames  = Array.from(db.schemas.keys());           // Use spread operator to get schema names as an array.\nlet public       = db.schemas.get('public');\nlet name         = public.name;\n\nfor (let schema of db.schemas.values()) {\n    console.log(schema.name);\n}\n\nfor (let [name, schema] of db.schemas) {\n    console.log(name, schema.name);\n}\n\n\n\n\n\n\ndb.get(path) \u21d2 \nSchema\n \n \nTable\n \n \nColumn\n \n \nundefined\n\n\nReturns \nSchema\n, \nTable\n or \nColumn\n on given path relative to \nDb\n. Path should be in dot (.) notation.\n\n\nKind\n: instance method of \nDb\n\n\nReturns\n: \nSchema\n \n \nTable\n \n \nColumn\n \n \nundefined\n - - Requested item.  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nstring\n\n\nPath of the requested item in dot (.) notation such as 'public.contact'\n\n\n\n\n\n\n\n\nExample\n  \n\n\nvar schema = db.get('public'),              // Returns public schema.\n    table  = db.get('public.contact'),      // Returns contact table in public schema.\n    column = db.get('public.contact.name'); // Returns name column of the contact table in public schema.", 
            "title": "Db"
        }, 
        {
            "location": "/api/Db/#db", 
            "text": "Class which represent a database. Provides attributes and methods for details of the database.  Kind : global class     Db  new Db(args, options)  .name  :  string  .fullName  :  string  .fullCatalogName  :  string  .options  :  Object  .schemas  :  Map. Schema  .get(path)  \u21d2  Schema     Table     Column     undefined", 
            "title": "Db"
        }, 
        {
            "location": "/api/Db/#new-dbargs-options", 
            "text": "Constructor function. You don't need to call constructor manually. pg-structure handles this.     Param  Type  Default  Description      args  Object   Attributes of the  Database  instance to be created.    args.name  Object   Name of the  Db  instance.    options  Object   Options to modify behaviour of classes.    [options.cache]  boolean  true  Use cache to memoize calculated results.", 
            "title": "new Db(args, options)"
        }, 
        {
            "location": "/api/Db/#dbname-string", 
            "text": "Name of the  Database .  Kind : instance property of  Db  Read only : true", 
            "title": "db.name : string"
        }, 
        {
            "location": "/api/Db/#dbfullname-string", 
            "text": "Full name of the  Database  with (.) notation. Since database does not have a parent this equals database name.  Kind : instance property of  Db  Read only : true", 
            "title": "db.fullName : string"
        }, 
        {
            "location": "/api/Db/#dbfullcatalogname-string", 
            "text": "Full name of the  Database  with (.) notation including catalog name. Since database does not have a parent this equals database name.  Kind : instance property of  Db  Read only : true", 
            "title": "db.fullCatalogName : string"
        }, 
        {
            "location": "/api/Db/#dboptions-object", 
            "text": "Options passed to during initialization.  Kind : instance property of  Db  Read only : true", 
            "title": "db.options : Object"
        }, 
        {
            "location": "/api/Db/#dbschemas-mapschema", 
            "text": "All  Schema  instances in the database as a  Map . Schemas are ordered by their name.  Kind : instance property of  Db  Read only : true  See :  Map  Example     let isAvailable  = db.schemas.has('another_schema');\nlet schemaNames  = Array.from(db.schemas.keys());           // Use spread operator to get schema names as an array.\nlet public       = db.schemas.get('public');\nlet name         = public.name;\n\nfor (let schema of db.schemas.values()) {\n    console.log(schema.name);\n}\n\nfor (let [name, schema] of db.schemas) {\n    console.log(name, schema.name);\n}", 
            "title": "db.schemas : Map.&lt;Schema&gt;"
        }, 
        {
            "location": "/api/Db/#dbgetpath-schema-table-column-undefined", 
            "text": "Returns  Schema ,  Table  or  Column  on given path relative to  Db . Path should be in dot (.) notation.  Kind : instance method of  Db  Returns :  Schema     Table     Column     undefined  - - Requested item.       Param  Type  Description      path  string  Path of the requested item in dot (.) notation such as 'public.contact'     Example     var schema = db.get('public'),              // Returns public schema.\n    table  = db.get('public.contact'),      // Returns contact table in public schema.\n    column = db.get('public.contact.name'); // Returns name column of the contact table in public schema.", 
            "title": "db.get(path) \u21d2 Schema &#124; Table &#124; Column &#124; undefined"
        }, 
        {
            "location": "/api/Index/", 
            "text": "Index\n\n\nClass which represent a database index. Provides attributes and methods for details of the index.\n\n\nKind\n: global class  \n\n\n\n\nIndex\n\n\nnew Index(args)\n\n\n.name\n : \nstring\n\n\n.fullName\n : \nstring\n\n\n.fullCatalogName\n : \nstring\n\n\n.isUnique\n : \nboolean\n\n\n.isPrimaryKey\n : \nboolean\n\n\n.table\n : \nTable\n\n\n.parent\n : \nTable\n\n\n.db\n : \nDb\n\n\n.schema\n : \nSchema\n\n\n.columns\n : \nArray.\nColumn\n\n\n.columnsByName\n : \nObject.\nstring, Column\n\n\n\n\n\n\n\n\n\n\nnew Index(args)\n\n\nConstructor function. You don't need to call constructor manually. pg-structure handles this.\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nargs\n\n\nObject\n\n\nAttributes of the \nIndex\n instance to be created.\n\n\n\n\n\n\nargs.name\n\n\nstring\n\n\nName of the Index.\n\n\n\n\n\n\nargs.isUnique\n\n\nstring\n\n\nIs it a unique index.\n\n\n\n\n\n\nargs.isPrimaryKey\n\n\nstring\n\n\nIs it a primary key index.\n\n\n\n\n\n\nargs.parent\n\n\nTable\n\n\nParent \nTable\n of the Index.\n\n\n\n\n\n\n\n\n\n\nindex.name : \nstring\n\n\nName of the index.\n\n\nKind\n: instance property of \nIndex\n\n\nRead only\n: true\n\n\n\n\nindex.fullName : \nstring\n\n\nFull name of the \nindex\n with (.) notation.\n\n\nKind\n: instance property of \nIndex\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nvar fullName = index.fullName; // crm.public\n\n\n\n\n\n\nindex.fullCatalogName : \nstring\n\n\nFull name of the \nindex\n with (.) notation including catalog name.\n\n\nKind\n: instance property of \nIndex\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nvar fullCatalogName = index.fullCatalogName; // crm.public\n\n\n\n\n\n\nindex.isUnique : \nboolean\n\n\nIf true, this is a unique index.\n\n\nKind\n: instance property of \nIndex\n\n\nRead only\n: true\n\n\n\n\nindex.isPrimaryKey : \nboolean\n\n\nIf true, this index represents the primary key of the table (\nisUnique\n is always true for primary keys.)\n\n\nKind\n: instance property of \nIndex\n\n\nRead only\n: true\n\n\n\n\nindex.table : \nTable\n\n\nTable\n which this \nindex\n belongs to.\n\n\nKind\n: instance property of \nIndex\n\n\nRead only\n: true\n\n\n\n\nindex.parent : \nTable\n\n\nTable\n which this \nindex\n belongs to.\n\n\nKind\n: instance property of \nIndex\n\n\nRead only\n: true\n\n\n\n\nindex.db : \nDb\n\n\nDb\n this \nindex\n belongs to.\n\n\nKind\n: instance property of \nIndex\n\n\nRead only\n: true\n\n\n\n\nindex.schema : \nSchema\n\n\nSchema\n this \nindex\n belongs to.\n\n\nKind\n: instance property of \nIndex\n\n\nRead only\n: true\n\n\n\n\nindex.columns : \nArray.\nColumn\n\n\nList of \ncolumns\n restricted by \nindex\n, in order their ordinal position\nwithin the index key. If \nindex\n does not have any \ncolumns\n this is \nnull\n.\n\n\nKind\n: instance property of \nIndex\n\n\nRead only\n: true\n\n\n\n\nindex.columnsByName : \nObject.\nstring, Column\n\n\nList of columns restricted by \nindex\n, in order their ordinal position within the index key.\nIf \nindex\n does not have any columns this is \nnull\n.\n\n\nKind\n: instance property of \nIndex\n\n\nRead only\n: true", 
            "title": "Index"
        }, 
        {
            "location": "/api/Index/#index", 
            "text": "Class which represent a database index. Provides attributes and methods for details of the index.  Kind : global class     Index  new Index(args)  .name  :  string  .fullName  :  string  .fullCatalogName  :  string  .isUnique  :  boolean  .isPrimaryKey  :  boolean  .table  :  Table  .parent  :  Table  .db  :  Db  .schema  :  Schema  .columns  :  Array. Column  .columnsByName  :  Object. string, Column", 
            "title": "Index"
        }, 
        {
            "location": "/api/Index/#new-indexargs", 
            "text": "Constructor function. You don't need to call constructor manually. pg-structure handles this.     Param  Type  Description      args  Object  Attributes of the  Index  instance to be created.    args.name  string  Name of the Index.    args.isUnique  string  Is it a unique index.    args.isPrimaryKey  string  Is it a primary key index.    args.parent  Table  Parent  Table  of the Index.", 
            "title": "new Index(args)"
        }, 
        {
            "location": "/api/Index/#indexname-string", 
            "text": "Name of the index.  Kind : instance property of  Index  Read only : true", 
            "title": "index.name : string"
        }, 
        {
            "location": "/api/Index/#indexfullname-string", 
            "text": "Full name of the  index  with (.) notation.  Kind : instance property of  Index  Read only : true  Example     var fullName = index.fullName; // crm.public", 
            "title": "index.fullName : string"
        }, 
        {
            "location": "/api/Index/#indexfullcatalogname-string", 
            "text": "Full name of the  index  with (.) notation including catalog name.  Kind : instance property of  Index  Read only : true  Example     var fullCatalogName = index.fullCatalogName; // crm.public", 
            "title": "index.fullCatalogName : string"
        }, 
        {
            "location": "/api/Index/#indexisunique-boolean", 
            "text": "If true, this is a unique index.  Kind : instance property of  Index  Read only : true", 
            "title": "index.isUnique : boolean"
        }, 
        {
            "location": "/api/Index/#indexisprimarykey-boolean", 
            "text": "If true, this index represents the primary key of the table ( isUnique  is always true for primary keys.)  Kind : instance property of  Index  Read only : true", 
            "title": "index.isPrimaryKey : boolean"
        }, 
        {
            "location": "/api/Index/#indextable-table", 
            "text": "Table  which this  index  belongs to.  Kind : instance property of  Index  Read only : true", 
            "title": "index.table : Table"
        }, 
        {
            "location": "/api/Index/#indexparent-table", 
            "text": "Table  which this  index  belongs to.  Kind : instance property of  Index  Read only : true", 
            "title": "index.parent : Table"
        }, 
        {
            "location": "/api/Index/#indexdb-db", 
            "text": "Db  this  index  belongs to.  Kind : instance property of  Index  Read only : true", 
            "title": "index.db : Db"
        }, 
        {
            "location": "/api/Index/#indexschema-schema", 
            "text": "Schema  this  index  belongs to.  Kind : instance property of  Index  Read only : true", 
            "title": "index.schema : Schema"
        }, 
        {
            "location": "/api/Index/#indexcolumns-arraycolumn", 
            "text": "List of  columns  restricted by  index , in order their ordinal position\nwithin the index key. If  index  does not have any  columns  this is  null .  Kind : instance property of  Index  Read only : true", 
            "title": "index.columns : Array.&lt;Column&gt;"
        }, 
        {
            "location": "/api/Index/#indexcolumnsbyname-objectstring-column", 
            "text": "List of columns restricted by  index , in order their ordinal position within the index key.\nIf  index  does not have any columns this is  null .  Kind : instance property of  Index  Read only : true", 
            "title": "index.columnsByName : Object.&lt;string, Column&gt;"
        }, 
        {
            "location": "/api/M2MRelation/", 
            "text": "M2MRelation\n\n\nKind\n: global class  \n\n\n\n\nM2MRelation\n\n\nnew M2MRelation(args)\n\n\n.type\n : \nrelationType\n\n\n.sourceTable\n : \nTable\n\n\n.joinTable\n : \nTable\n\n\n.targetTable\n : \nTable\n\n\n.sourceConstraint\n : \nTable\n\n\n.targetConstraint\n : \nTable\n\n\n.generateName([strategy])\n \u21d2 \nstring\n\n\n\n\n\n\n\n\n\n\nnew M2MRelation(args)\n\n\nClass which represent a many to many relationship which resembles \nbelongsToMany\n or \nhasManyThrough\n relations in ORMs (Object Relational Mappers).\nProvides attributes and methods for details of the relationship.\n\n\nActually there isn't such a thing called \nmany to many relationship\n or \nthrough constraint\n in the database engine.\nThey are concepts to describe records which may be related more than one record on both sides.\nFor example an invoice may contain more than product and a product may related to more than one invoice.\nThose relationships are solved a so called many to many \njoin table\n.\n\n\nSince those relations are not present in database engine, they are extracted by estimation/interpretation.\nMany non-join tables in a database could have more than one foreign key constraints,\nand they may not meant to be join tables, but they still appear to have through relationships.\n\n\nBelow is a database schema as an example:\n\n\nsize -------------------\nid (PK)                |  ---------------------------\n line_item \n------------ cart\nname                   |  |                            product_id (PFK)        id (PK)\n                       |  |                            cart_id    (PFK)        name\n                       ^  |\ncolor -------------\n product \n------------- vendor\nid (PK)              id        (PK)         id (PK)\nname                 name                   name\n                     color_id  (FK)\n                     size_id   (FK)\n                     vendor_id (FK)\n\n\n\n\n\nBelow is the same schema as image:\n\n\n\nSome definitions used in descriptions for \nM2MRelation\n.\n\n \n Source Table: \n Table which this relationship belongs to.\n\n \n Join Table: \n Table that contains common fields from two or more other tables.\n* \n Target Table: \n Table that is related to base table through a join table.\n\n\nProduct table has 3 foreign key constraints. Product table is not meant to be a many to many join table.\nHowever product could have been join table for \nsize \n vendor\n, \ncolor \n vendor\n and \nsize \n color\n. As a result size,\ncolor and vendor tables would have many to many relationships.\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nargs\n\n\nObject\n\n\nAttributes of the \nM2MRelation\n instance to be created.\n\n\n\n\n\n\nargs.sourceTable\n\n\nTable\n\n\nSource \nTable\n which this relation belongs to.\n\n\n\n\n\n\nargs.joinTable\n\n\nTable\n\n\nJoin \nTable\n of this relationship.\n\n\n\n\n\n\nargs.targetTable\n\n\nTable\n\n\nTarget \nTable\n which this relation is referring to through a join table.\n\n\n\n\n\n\nargs.sourceConstraint\n\n\nConstraint\n\n\nForeign key constraint between source table and join table.\n\n\n\n\n\n\nargs.targetConstraint\n\n\nConstraint\n\n\nForeign key constraint between join table and target table.\n\n\n\n\n\n\n\n\nExample\n  \n\n\n// Example tables have single primary key and and examples first relation. So zero index ([0]) is used. Use all array elements if necessary.\n// product ----\n line_item \n---- cart\n// (source)        (join)       (target)\n\nlet relation             = product.m2mRelations[0];              // RELATION:    product ---\n line_item \n--- cart\nlet sourceConstraint     = relation.sourceConstraint;            // CONSTRAINT:           ^-- product_has_carts\nlet targetConstraint     = relation.targetConstraint;            // CONSTRAINT:       cart_has_products --^\nlet sourceTable          = relation.sourceTable;                 // TABLE:       product\nlet targetTable          = relation.targetTable;                 // TABLE:       cart\nlet sourceJoinFKColumn   = relation.sourceConstraint.columns[0]; // COLUMN:      product_id  (from line_item table)\nlet targetJoinFKColumn   = relation.targetConstraint.columns[0]; // COLUMN:      cart_id     (from line_item table)\nlet sourcePKColumn       = relation.sourceTable.primaryKeys[0];  // COLUMN:      id          (from product table)\nlet targetPKColumn       = relation.targetTable.primaryKeys[0];  // COLUMN:      id          (from cart table)\n\n\n\n\n\n\nm2MRelation.type : \nrelationType\n\n\nType of relation which is \nMANY TO MANY\n.\n\n\nKind\n: instance property of \nM2MRelation\n\n\nRead only\n: true\n\n\n\n\nm2MRelation.sourceTable : \nTable\n\n\nTable\n which this relation belongs to.\n\n\nKind\n: instance property of \nM2MRelation\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nlet relation = product.M2MRelationRelations[0];  // RELATION:    product ---\n line_item \n--- cart\nlet source   = relation.sourceTable;             // TABLE:       product\n\n\n\n\n\n\nm2MRelation.joinTable : \nTable\n\n\nJoin \nTable\n of this relationship. This table contains foreign key columns referring both\n\nsourceTable\n and \ntargetTable\n.\n\n\nKind\n: instance property of \nM2MRelation\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nlet relation  = product.M2MRelationRelations[0]; // RELATION:    product ---\n line_item \n--- cart\nlet joinTable = relation.joinTable;              // TABLE:       line_item\n\n\n\n\n\n\nm2MRelation.targetTable : \nTable\n\n\nTable\n which this relation is referring to (Through a join table).\n\n\nKind\n: instance property of \nM2MRelation\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nlet relation = product.M2MRelationRelations[0];  // RELATION:    product ---\n line_item \n--- cart\nlet target   = relation.targetTable;             // TABLE:       cart\n\n\n\n\n\n\nm2MRelation.sourceConstraint : \nTable\n\n\nForeign key \nconstraint\n between \nsource table\n and \njoin table\n.\n\n\nKind\n: instance property of \nM2MRelation\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nlet relation             = product.M2MRelationRelations[0];      // RELATION:    product ---\n line_item \n--- cart\nlet sourceConstraint     = relation.sourceConstraint;            // CONSTRAINT:           ^-- product_has_carts\nlet sourceJoinFKColumn   = relation.sourceConstraint.columns[0]; // COLUMN:      product_id (from line_item table)\n\n\n\n\n\n\nm2MRelation.targetConstraint : \nTable\n\n\nForeign key \nconstraint\n between \njoin table\n and \ntarget table\n.\n\n\nKind\n: instance property of \nM2MRelation\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nlet relation             = product.M2MRelationRelations[0];      // RELATION:    product ---\n line_item \n--- cart\nlet targetConstraint     = relation.targetConstraint;            // CONSTRAINT:       cart_has_products --^\nlet targetJoinFKColumn   = relation.targetConstraint.columns[0]; // COLUMN:      cart_id (from line_item table)\n\n\n\n\n\n\nm2MRelation.generateName([strategy]) \u21d2 \nstring\n\n\n(! EXPERIMENTAL) Returns name for relation using given strategy. Please see \nRelation Names\n for details.\n\n\nKind\n: instance method of \nM2MRelation\n\n\nReturns\n: \nstring\n - - Relation name.\n\n\nSee\n: \nRelation Names\n  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n[strategy]\n\n\nstring\n\n\n(simple, complex) Naming strategy to use.", 
            "title": "M2M Relation"
        }, 
        {
            "location": "/api/M2MRelation/#m2mrelation", 
            "text": "Kind : global class     M2MRelation  new M2MRelation(args)  .type  :  relationType  .sourceTable  :  Table  .joinTable  :  Table  .targetTable  :  Table  .sourceConstraint  :  Table  .targetConstraint  :  Table  .generateName([strategy])  \u21d2  string", 
            "title": "M2MRelation"
        }, 
        {
            "location": "/api/M2MRelation/#new-m2mrelationargs", 
            "text": "Class which represent a many to many relationship which resembles  belongsToMany  or  hasManyThrough  relations in ORMs (Object Relational Mappers).\nProvides attributes and methods for details of the relationship.  Actually there isn't such a thing called  many to many relationship  or  through constraint  in the database engine.\nThey are concepts to describe records which may be related more than one record on both sides.\nFor example an invoice may contain more than product and a product may related to more than one invoice.\nThose relationships are solved a so called many to many  join table .  Since those relations are not present in database engine, they are extracted by estimation/interpretation.\nMany non-join tables in a database could have more than one foreign key constraints,\nand they may not meant to be join tables, but they still appear to have through relationships.  Below is a database schema as an example:  size -------------------\nid (PK)                |  ---------------------------  line_item  ------------ cart\nname                   |  |                            product_id (PFK)        id (PK)\n                       |  |                            cart_id    (PFK)        name\n                       ^  |\ncolor -------------  product  ------------- vendor\nid (PK)              id        (PK)         id (PK)\nname                 name                   name\n                     color_id  (FK)\n                     size_id   (FK)\n                     vendor_id (FK)  Below is the same schema as image:  Some definitions used in descriptions for  M2MRelation .    Source Table:   Table which this relationship belongs to.    Join Table:   Table that contains common fields from two or more other tables.\n*   Target Table:   Table that is related to base table through a join table. \nProduct table has 3 foreign key constraints. Product table is not meant to be a many to many join table.\nHowever product could have been join table for  size   vendor ,  color   vendor  and  size   color . As a result size,\ncolor and vendor tables would have many to many relationships.     Param  Type  Description      args  Object  Attributes of the  M2MRelation  instance to be created.    args.sourceTable  Table  Source  Table  which this relation belongs to.    args.joinTable  Table  Join  Table  of this relationship.    args.targetTable  Table  Target  Table  which this relation is referring to through a join table.    args.sourceConstraint  Constraint  Foreign key constraint between source table and join table.    args.targetConstraint  Constraint  Foreign key constraint between join table and target table.     Example     // Example tables have single primary key and and examples first relation. So zero index ([0]) is used. Use all array elements if necessary.\n// product ----  line_item  ---- cart\n// (source)        (join)       (target)\n\nlet relation             = product.m2mRelations[0];              // RELATION:    product ---  line_item  --- cart\nlet sourceConstraint     = relation.sourceConstraint;            // CONSTRAINT:           ^-- product_has_carts\nlet targetConstraint     = relation.targetConstraint;            // CONSTRAINT:       cart_has_products --^\nlet sourceTable          = relation.sourceTable;                 // TABLE:       product\nlet targetTable          = relation.targetTable;                 // TABLE:       cart\nlet sourceJoinFKColumn   = relation.sourceConstraint.columns[0]; // COLUMN:      product_id  (from line_item table)\nlet targetJoinFKColumn   = relation.targetConstraint.columns[0]; // COLUMN:      cart_id     (from line_item table)\nlet sourcePKColumn       = relation.sourceTable.primaryKeys[0];  // COLUMN:      id          (from product table)\nlet targetPKColumn       = relation.targetTable.primaryKeys[0];  // COLUMN:      id          (from cart table)", 
            "title": "new M2MRelation(args)"
        }, 
        {
            "location": "/api/M2MRelation/#m2mrelationtype-relationtype", 
            "text": "Type of relation which is  MANY TO MANY .  Kind : instance property of  M2MRelation  Read only : true", 
            "title": "m2MRelation.type : relationType"
        }, 
        {
            "location": "/api/M2MRelation/#m2mrelationsourcetable-table", 
            "text": "Table  which this relation belongs to.  Kind : instance property of  M2MRelation  Read only : true  Example     let relation = product.M2MRelationRelations[0];  // RELATION:    product ---  line_item  --- cart\nlet source   = relation.sourceTable;             // TABLE:       product", 
            "title": "m2MRelation.sourceTable : Table"
        }, 
        {
            "location": "/api/M2MRelation/#m2mrelationjointable-table", 
            "text": "Join  Table  of this relationship. This table contains foreign key columns referring both sourceTable  and  targetTable .  Kind : instance property of  M2MRelation  Read only : true  Example     let relation  = product.M2MRelationRelations[0]; // RELATION:    product ---  line_item  --- cart\nlet joinTable = relation.joinTable;              // TABLE:       line_item", 
            "title": "m2MRelation.joinTable : Table"
        }, 
        {
            "location": "/api/M2MRelation/#m2mrelationtargettable-table", 
            "text": "Table  which this relation is referring to (Through a join table).  Kind : instance property of  M2MRelation  Read only : true  Example     let relation = product.M2MRelationRelations[0];  // RELATION:    product ---  line_item  --- cart\nlet target   = relation.targetTable;             // TABLE:       cart", 
            "title": "m2MRelation.targetTable : Table"
        }, 
        {
            "location": "/api/M2MRelation/#m2mrelationsourceconstraint-table", 
            "text": "Foreign key  constraint  between  source table  and  join table .  Kind : instance property of  M2MRelation  Read only : true  Example     let relation             = product.M2MRelationRelations[0];      // RELATION:    product ---  line_item  --- cart\nlet sourceConstraint     = relation.sourceConstraint;            // CONSTRAINT:           ^-- product_has_carts\nlet sourceJoinFKColumn   = relation.sourceConstraint.columns[0]; // COLUMN:      product_id (from line_item table)", 
            "title": "m2MRelation.sourceConstraint : Table"
        }, 
        {
            "location": "/api/M2MRelation/#m2mrelationtargetconstraint-table", 
            "text": "Foreign key  constraint  between  join table  and  target table .  Kind : instance property of  M2MRelation  Read only : true  Example     let relation             = product.M2MRelationRelations[0];      // RELATION:    product ---  line_item  --- cart\nlet targetConstraint     = relation.targetConstraint;            // CONSTRAINT:       cart_has_products --^\nlet targetJoinFKColumn   = relation.targetConstraint.columns[0]; // COLUMN:      cart_id (from line_item table)", 
            "title": "m2MRelation.targetConstraint : Table"
        }, 
        {
            "location": "/api/M2MRelation/#m2mrelationgeneratenamestrategy-string", 
            "text": "(! EXPERIMENTAL) Returns name for relation using given strategy. Please see  Relation Names  for details.  Kind : instance method of  M2MRelation  Returns :  string  - - Relation name.  See :  Relation Names        Param  Type  Description      [strategy]  string  (simple, complex) Naming strategy to use.", 
            "title": "m2MRelation.generateName([strategy]) \u21d2 string"
        }, 
        {
            "location": "/api/M2ORelation/", 
            "text": "M2ORelation\n\n\nKind\n: global class  \n\n\n\n\nM2ORelation\n\n\nnew M2ORelation(args)\n\n\n.type\n : \nrelationType\n\n\n.sourceTable\n : \nTable\n\n\n.targetTable\n : \nTable\n\n\n.constraint\n : \nTable\n\n\n.generateName([strategy])\n \u21d2 \nstring\n\n\n\n\n\n\n\n\n\n\nnew M2ORelation(args)\n\n\nClass which represent many to one relationship which resembles \nbelongsTo\n relation in ORMs (Object Relational Mappers).\nProvides attributes and methods for details of the relationship.\n\n\nActually there is no many to one relation in database engine. It is basically one to many relation in reverse direction.\n\n\nBelow is a database schema as an example:\n\n\nsize -------------------\nid (PK)                |  ---------------------------\n line_item \n------------ cart\nname                   |  |                            product_id (PFK)        id (PK)\n                       |  |                            cart_id    (PFK)        name\n                       ^  |\ncolor -------------\n product \n------------- vendor\nid (PK)              id        (PK)         id (PK)\nname                 name                   name\n                     color_id  (FK)\n                     size_id   (FK)\n                     vendor_id (FK)\n\n\n\n\n\nBelow is the same schema as image:\n\n\n\nSome definitions used in descriptions for \nM2ORelation\n.\n\n \n Source Table: \n Table which this relationship belongs to.\n\n \n Target Table: \n Table that is related to base table.\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nargs\n\n\nObject\n\n\nAttributes of the \nM2ORelation\n instance to be created.\n\n\n\n\n\n\nargs.sourceTable\n\n\nTable\n\n\nSource \nTable\n which this relation belongs to.\n\n\n\n\n\n\nargs.targetTable\n\n\nTable\n\n\nTarget \nTable\n which this relation is referring to.\n\n\n\n\n\n\nargs.constraint\n\n\nConstraint\n\n\nForeign key constraint between source table and target table.\n\n\n\n\n\n\nargs.namingStrategy\n\n\nstring\n\n\nNaming strategy to be used.\n\n\n\n\n\n\n\n\nExample\n  \n\n\n// Example tables have single primary key and examples first relation. So zero index ([0]) is used. Use all array elements if necessary.\n// line_item \n---- product\n// (source)        (target)\n\nlet relation     = line_item.m2oRelations[0];            // RELATION:    line_item \n---- product\nlet constraint   = relation.constraint;                  // CONSTRAINT:               ^-- product_has_carts\nlet sourceTable  = relation.sourceTable;                 // TABLE:       line_item\nlet targetTable  = relation.targetTable;                 // TABLE:       product\nlet FKColumn     = relation.constraint.columns[0];       // COLUMN:      product_id  (from line_item table)\nlet PKColumn     = relation.targetTable.primaryKeys[0];  // COLUMN:      id          (from product table)\n\n\n\n\n\n\nm2ORelation.type : \nrelationType\n\n\nType of relation which is \nMANY TO ONE\n.\n\n\nKind\n: instance property of \nM2ORelation\n\n\nRead only\n: true\n\n\n\n\nm2ORelation.sourceTable : \nTable\n\n\nTable\n which this relation belongs to.\n\n\nKind\n: instance property of \nM2ORelation\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nlet relation     = product.M2ORelationRelations[0];  // RELATION:    line_item \n---- product\nlet sourceTable  = relation.sourceTable;             // TABLE:       line_item\n\n\n\n\n\n\nm2ORelation.targetTable : \nTable\n\n\nTable\n which this relation is referred by.\n\n\nKind\n: instance property of \nM2ORelation\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nlet relation     = product.M2ORelationRelations[0];  // RELATION:    line_item \n---- product\nlet targetTable  = relation.targetTable;             // TABLE:       product\n\n\n\n\n\n\nm2ORelation.constraint : \nTable\n\n\nForeign key \nconstraint\n between \nsource table\n and \ntarget table\n.\n\n\nKind\n: instance property of \nM2ORelation\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nlet relation     = product.M2ORelationRelations[0];  // RELATION:    line_item \n---- product\nlet constraint   = relation.constraint;              // CONSTRAINT:               ^-- product_has_carts\nlet FKColumn     = relation.constraint.columns[0];   // COLUMN:      product_id (from line_item table)\n\n\n\n\n\n\nm2ORelation.generateName([strategy]) \u21d2 \nstring\n\n\n(! EXPERIMENTAL) Returns name for relation using given strategy. Please see \nRelation Names\n for details.\n\n\nKind\n: instance method of \nM2ORelation\n\n\nReturns\n: \nstring\n - - Relation name.\n\n\nSee\n: \nRelation Names\n  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n[strategy]\n\n\nstring\n\n\n(simple, complex) Naming strategy to use.", 
            "title": "M2O Relation"
        }, 
        {
            "location": "/api/M2ORelation/#m2orelation", 
            "text": "Kind : global class     M2ORelation  new M2ORelation(args)  .type  :  relationType  .sourceTable  :  Table  .targetTable  :  Table  .constraint  :  Table  .generateName([strategy])  \u21d2  string", 
            "title": "M2ORelation"
        }, 
        {
            "location": "/api/M2ORelation/#new-m2orelationargs", 
            "text": "Class which represent many to one relationship which resembles  belongsTo  relation in ORMs (Object Relational Mappers).\nProvides attributes and methods for details of the relationship.  Actually there is no many to one relation in database engine. It is basically one to many relation in reverse direction.  Below is a database schema as an example:  size -------------------\nid (PK)                |  ---------------------------  line_item  ------------ cart\nname                   |  |                            product_id (PFK)        id (PK)\n                       |  |                            cart_id    (PFK)        name\n                       ^  |\ncolor -------------  product  ------------- vendor\nid (PK)              id        (PK)         id (PK)\nname                 name                   name\n                     color_id  (FK)\n                     size_id   (FK)\n                     vendor_id (FK)  Below is the same schema as image:  Some definitions used in descriptions for  M2ORelation .    Source Table:   Table which this relationship belongs to.    Target Table:   Table that is related to base table.     Param  Type  Description      args  Object  Attributes of the  M2ORelation  instance to be created.    args.sourceTable  Table  Source  Table  which this relation belongs to.    args.targetTable  Table  Target  Table  which this relation is referring to.    args.constraint  Constraint  Foreign key constraint between source table and target table.    args.namingStrategy  string  Naming strategy to be used.     Example     // Example tables have single primary key and examples first relation. So zero index ([0]) is used. Use all array elements if necessary.\n// line_item  ---- product\n// (source)        (target)\n\nlet relation     = line_item.m2oRelations[0];            // RELATION:    line_item  ---- product\nlet constraint   = relation.constraint;                  // CONSTRAINT:               ^-- product_has_carts\nlet sourceTable  = relation.sourceTable;                 // TABLE:       line_item\nlet targetTable  = relation.targetTable;                 // TABLE:       product\nlet FKColumn     = relation.constraint.columns[0];       // COLUMN:      product_id  (from line_item table)\nlet PKColumn     = relation.targetTable.primaryKeys[0];  // COLUMN:      id          (from product table)", 
            "title": "new M2ORelation(args)"
        }, 
        {
            "location": "/api/M2ORelation/#m2orelationtype-relationtype", 
            "text": "Type of relation which is  MANY TO ONE .  Kind : instance property of  M2ORelation  Read only : true", 
            "title": "m2ORelation.type : relationType"
        }, 
        {
            "location": "/api/M2ORelation/#m2orelationsourcetable-table", 
            "text": "Table  which this relation belongs to.  Kind : instance property of  M2ORelation  Read only : true  Example     let relation     = product.M2ORelationRelations[0];  // RELATION:    line_item  ---- product\nlet sourceTable  = relation.sourceTable;             // TABLE:       line_item", 
            "title": "m2ORelation.sourceTable : Table"
        }, 
        {
            "location": "/api/M2ORelation/#m2orelationtargettable-table", 
            "text": "Table  which this relation is referred by.  Kind : instance property of  M2ORelation  Read only : true  Example     let relation     = product.M2ORelationRelations[0];  // RELATION:    line_item  ---- product\nlet targetTable  = relation.targetTable;             // TABLE:       product", 
            "title": "m2ORelation.targetTable : Table"
        }, 
        {
            "location": "/api/M2ORelation/#m2orelationconstraint-table", 
            "text": "Foreign key  constraint  between  source table  and  target table .  Kind : instance property of  M2ORelation  Read only : true  Example     let relation     = product.M2ORelationRelations[0];  // RELATION:    line_item  ---- product\nlet constraint   = relation.constraint;              // CONSTRAINT:               ^-- product_has_carts\nlet FKColumn     = relation.constraint.columns[0];   // COLUMN:      product_id (from line_item table)", 
            "title": "m2ORelation.constraint : Table"
        }, 
        {
            "location": "/api/M2ORelation/#m2orelationgeneratenamestrategy-string", 
            "text": "(! EXPERIMENTAL) Returns name for relation using given strategy. Please see  Relation Names  for details.  Kind : instance method of  M2ORelation  Returns :  string  - - Relation name.  See :  Relation Names        Param  Type  Description      [strategy]  string  (simple, complex) Naming strategy to use.", 
            "title": "m2ORelation.generateName([strategy]) \u21d2 string"
        }, 
        {
            "location": "/api/Map/", 
            "text": "Map\n\n\nThe Map object is a simple key/value map. Any value (both objects and primitive values) may be used as either a key\nor a value.\n\n\nKind\n: global class\n\n\nSee\n: \nMozilla Map Documentation\n  \n\n\n\n\nMap\n\n\n.size\n : \nnumber\n\n\n.array\n : \nArray\n\n\n.entries()\n \u21d2 \nIterator\n\n\n.forEach(callbackFn, this)\n\n\n.get(name)\n \u21d2 \n*\n\n\n.has(name)\n \u21d2 \nboolean\n\n\n.keys()\n \u21d2 \nIterator\n\n\n.values()\n \u21d2 \nIterator\n\n\n\n\n\n\n\n\n\n\nmap.size : \nnumber\n\n\nThe number of key/value pairs in the Map object.\n\n\nKind\n: instance property of \nMap\n\n\nExample\n  \n\n\nlet size = db.get('public.account').columns.size;\n\n\n\n\n\n\nmap.array : \nArray\n\n\nNot part of Map standard.\nValues of Map as an array.\n\n\nKind\n: instance property of \nMap\n\n\nExample\n  \n\n\nlet schemasArray = db.schemas.array;\n\n\n\n\n\n\nmap.entries() \u21d2 \nIterator\n\n\nReturns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order.\n\n\nKind\n: instance method of \nMap\n\n\nExample\n  \n\n\nlet column = db.get('public.account').columns.get('name');\n\n\n\n\n\n\nmap.forEach(callbackFn, this)\n\n\nCalls callbackFn once for each key-value pair present in the Map object, in insertion order.\nIf a thisArg parameter is provided to forEach, it will be used as the this value for each callback.\n\n\nKind\n: instance method of \nMap\n  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncallbackFn\n\n\nfunction\n\n\nFunction to call for each pair.\n\n\n\n\n\n\nthis\n\n\nObject\n\n\nContext.\n\n\n\n\n\n\n\n\n\n\nmap.get(name) \u21d2 \n*\n\n\nReturns the value associated to the key, or undefined if there is none.\n\n\nKind\n: instance method of \nMap\n\n\nReturns\n: \n*\n - - Value associated to key.  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nName of the item to get.\n\n\n\n\n\n\n\n\nExample\n  \n\n\nlet column = db.get('public.account').columns.get('name');\n\n\n\n\n\n\nmap.has(name) \u21d2 \nboolean\n\n\nReturns a boolean asserting whether a value has been associated to the key in the Map object or not.\n\n\nKind\n: instance method of \nMap\n\n\nReturns\n: \nboolean\n - - \ntrue\n if key exists.  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nstring\n\n\nName of the item to test.\n\n\n\n\n\n\n\n\nExample\n  \n\n\nlet exists = db.schemas.has('public'); // true\n\n\n\n\n\n\nmap.keys() \u21d2 \nIterator\n\n\nReturns a new Iterator object that contains the keys for each element in the Map object in insertion order.\n\n\nKind\n: instance method of \nMap\n\n\nExample\n  \n\n\nfor (let tableName of db.schemas.get('public').tables.keys()) {\n    console.log(tableName);\n}\n\nlet tableNames = Array.from(db.schemas.get('public').tables.keys()); // Table names as an array.\n\n\n\n\n\n\nmap.values() \u21d2 \nIterator\n\n\nReturns a new Iterator object that contains the values for each element in the Map object in insertion order.\n\n\nKind\n: instance method of \nMap\n\n\nExample\n  \n\n\nfor (let table of db.schemas.get('public').tables.values()) {\n    console.log(table.name);\n}\n\nlet tables = Array.from(db.schemas.get('public').tables.values()); // Table objects as an array.", 
            "title": "Map"
        }, 
        {
            "location": "/api/Map/#map", 
            "text": "The Map object is a simple key/value map. Any value (both objects and primitive values) may be used as either a key\nor a value.  Kind : global class  See :  Mozilla Map Documentation      Map  .size  :  number  .array  :  Array  .entries()  \u21d2  Iterator  .forEach(callbackFn, this)  .get(name)  \u21d2  *  .has(name)  \u21d2  boolean  .keys()  \u21d2  Iterator  .values()  \u21d2  Iterator", 
            "title": "Map"
        }, 
        {
            "location": "/api/Map/#mapsize-number", 
            "text": "The number of key/value pairs in the Map object.  Kind : instance property of  Map  Example     let size = db.get('public.account').columns.size;", 
            "title": "map.size : number"
        }, 
        {
            "location": "/api/Map/#maparray-array", 
            "text": "Not part of Map standard.\nValues of Map as an array.  Kind : instance property of  Map  Example     let schemasArray = db.schemas.array;", 
            "title": "map.array : Array"
        }, 
        {
            "location": "/api/Map/#mapentries-iterator", 
            "text": "Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order.  Kind : instance method of  Map  Example     let column = db.get('public.account').columns.get('name');", 
            "title": "map.entries() \u21d2 Iterator"
        }, 
        {
            "location": "/api/Map/#mapforeachcallbackfn-this", 
            "text": "Calls callbackFn once for each key-value pair present in the Map object, in insertion order.\nIf a thisArg parameter is provided to forEach, it will be used as the this value for each callback.  Kind : instance method of  Map        Param  Type  Description      callbackFn  function  Function to call for each pair.    this  Object  Context.", 
            "title": "map.forEach(callbackFn, this)"
        }, 
        {
            "location": "/api/Map/#mapgetname-42", 
            "text": "Returns the value associated to the key, or undefined if there is none.  Kind : instance method of  Map  Returns :  *  - - Value associated to key.       Param  Type  Description      name  string  Name of the item to get.     Example     let column = db.get('public.account').columns.get('name');", 
            "title": "map.get(name) \u21d2 *"
        }, 
        {
            "location": "/api/Map/#maphasname-boolean", 
            "text": "Returns a boolean asserting whether a value has been associated to the key in the Map object or not.  Kind : instance method of  Map  Returns :  boolean  - -  true  if key exists.       Param  Type  Description      name  string  Name of the item to test.     Example     let exists = db.schemas.has('public'); // true", 
            "title": "map.has(name) \u21d2 boolean"
        }, 
        {
            "location": "/api/Map/#mapkeys-iterator", 
            "text": "Returns a new Iterator object that contains the keys for each element in the Map object in insertion order.  Kind : instance method of  Map  Example     for (let tableName of db.schemas.get('public').tables.keys()) {\n    console.log(tableName);\n}\n\nlet tableNames = Array.from(db.schemas.get('public').tables.keys()); // Table names as an array.", 
            "title": "map.keys() \u21d2 Iterator"
        }, 
        {
            "location": "/api/Map/#mapvalues-iterator", 
            "text": "Returns a new Iterator object that contains the values for each element in the Map object in insertion order.  Kind : instance method of  Map  Example     for (let table of db.schemas.get('public').tables.values()) {\n    console.log(table.name);\n}\n\nlet tables = Array.from(db.schemas.get('public').tables.values()); // Table objects as an array.", 
            "title": "map.values() \u21d2 Iterator"
        }, 
        {
            "location": "/api/O2MRelation/", 
            "text": "O2MRelation\n\n\nKind\n: global class  \n\n\n\n\nO2MRelation\n\n\nnew O2MRelation(args)\n\n\n.type\n : \nrelationType\n\n\n.sourceTable\n : \nTable\n\n\n.targetTable\n : \nTable\n\n\n.constraint\n : \nTable\n\n\n.generateName([strategy])\n \u21d2 \nstring\n\n\n\n\n\n\n\n\n\n\nnew O2MRelation(args)\n\n\nClass which represent one to many relationship which resembles \nhasMany\n relation in ORMs (Object Relational Mappers).\nProvides attributes and methods for details of the relationship.\n\n\nBelow is a database schema as an example:\n\n\nsize -------------------\nid (PK)                |  ---------------------------\n line_item \n------------ cart\nname                   |  |                            product_id (PFK)        id (PK)\n                       |  |                            cart_id    (PFK)        name\n                       ^  |\ncolor -------------\n product \n------------- vendor\nid (PK)              id        (PK)         id (PK)\nname                 name                   name\n                     color_id  (FK)\n                     size_id   (FK)\n                     vendor_id (FK)\n\n\n\n\n\nBelow is the same schema as image:\n\n\n\nSome definitions used in descriptions for \nO2MRelation\n.\n\n \n Source Table: \n Table which this relationship belongs to.\n\n \n Target Table: \n Table that is related to base table.\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nargs\n\n\nObject\n\n\nAttributes of the \nO2MRelation\n instance to be created.\n\n\n\n\n\n\nargs.sourceTable\n\n\nTable\n\n\nSource \nTable\n which this relation belongs to.\n\n\n\n\n\n\nargs.targetTable\n\n\nTable\n\n\nTarget \nTable\n which this relation is referring to.\n\n\n\n\n\n\nargs.constraint\n\n\nConstraint\n\n\nForeign key constraint between source table and target table.\n\n\n\n\n\n\n\n\nExample\n  \n\n\n// Example tables have single primary key and examples first relation. So zero index ([0]) is used. Use all array elements if necessary.\n// product ----\n line_item\n// (source)       (target)\n\nlet relation         = product.o2mRelations[0];              // RELATION:    product ---\n line_item\nlet constraint       = relation.constraint;                  // CONSTRAINT:           ^-- product_has_carts\nlet sourceTable      = relation.sourceTable;                 // TABLE:       product\nlet targetTable      = relation.targetTable;                 // TABLE:       line_item\nlet FKColumn         = relation.constraint.columns[0];       // COLUMN:      product_id  (from line_item table)\nlet sourcePKColumn   = relation.sourceTable.primaryKeys[0];  // COLUMN:      id          (from product table)\n\n\n\n\n\n\no2MRelation.type : \nrelationType\n\n\nType of relation which is \nONE TO MANY\n.\n\n\nKind\n: instance property of \nO2MRelation\n\n\nRead only\n: true\n\n\n\n\no2MRelation.sourceTable : \nTable\n\n\nTable\n which this relation belongs to.\n\n\nKind\n: instance property of \nO2MRelation\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nlet relation     = product.O2MRelationRelations[0];  // RELATION:    product ---\n line_item\nlet sourceTable  = relation.sourceTable;             // TABLE:       product\n\n\n\n\n\n\no2MRelation.targetTable : \nTable\n\n\nTable\n which this relation is referring to.\n\n\nKind\n: instance property of \nO2MRelation\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nlet relation     = product.O2MRelationRelations[0];  // RELATION:    product ---\n line_item\nlet targetTable  = relation.targetTable;             // TABLE:       line_item\n\n\n\n\n\n\no2MRelation.constraint : \nTable\n\n\nForeign key \nconstraint\n between \nsource table\n and \ntarget table\n.\n\n\nKind\n: instance property of \nO2MRelation\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nlet relation     = product.O2MRelationRelations[0];  // RELATION:    product ---\n line_item\nlet constraint   = relation.constraint;              // CONSTRAINT:           ^-- product_has_carts\nlet FKColumn     = relation.constraint.columns[0];   // COLUMN:      product_id (from line_item table)\n\n\n\n\n\n\no2MRelation.generateName([strategy]) \u21d2 \nstring\n\n\n(! EXPERIMENTAL) Returns name for relation using given strategy. Please see \nRelation Names\n for details.\n\n\nKind\n: instance method of \nO2MRelation\n\n\nReturns\n: \nstring\n - - Relation name.\n\n\nSee\n: \nRelation Names\n  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n[strategy]\n\n\nstring\n\n\n(simple, complex) Naming strategy to use.", 
            "title": "O2M Relation"
        }, 
        {
            "location": "/api/O2MRelation/#o2mrelation", 
            "text": "Kind : global class     O2MRelation  new O2MRelation(args)  .type  :  relationType  .sourceTable  :  Table  .targetTable  :  Table  .constraint  :  Table  .generateName([strategy])  \u21d2  string", 
            "title": "O2MRelation"
        }, 
        {
            "location": "/api/O2MRelation/#new-o2mrelationargs", 
            "text": "Class which represent one to many relationship which resembles  hasMany  relation in ORMs (Object Relational Mappers).\nProvides attributes and methods for details of the relationship.  Below is a database schema as an example:  size -------------------\nid (PK)                |  ---------------------------  line_item  ------------ cart\nname                   |  |                            product_id (PFK)        id (PK)\n                       |  |                            cart_id    (PFK)        name\n                       ^  |\ncolor -------------  product  ------------- vendor\nid (PK)              id        (PK)         id (PK)\nname                 name                   name\n                     color_id  (FK)\n                     size_id   (FK)\n                     vendor_id (FK)  Below is the same schema as image:  Some definitions used in descriptions for  O2MRelation .    Source Table:   Table which this relationship belongs to.    Target Table:   Table that is related to base table.     Param  Type  Description      args  Object  Attributes of the  O2MRelation  instance to be created.    args.sourceTable  Table  Source  Table  which this relation belongs to.    args.targetTable  Table  Target  Table  which this relation is referring to.    args.constraint  Constraint  Foreign key constraint between source table and target table.     Example     // Example tables have single primary key and examples first relation. So zero index ([0]) is used. Use all array elements if necessary.\n// product ----  line_item\n// (source)       (target)\n\nlet relation         = product.o2mRelations[0];              // RELATION:    product ---  line_item\nlet constraint       = relation.constraint;                  // CONSTRAINT:           ^-- product_has_carts\nlet sourceTable      = relation.sourceTable;                 // TABLE:       product\nlet targetTable      = relation.targetTable;                 // TABLE:       line_item\nlet FKColumn         = relation.constraint.columns[0];       // COLUMN:      product_id  (from line_item table)\nlet sourcePKColumn   = relation.sourceTable.primaryKeys[0];  // COLUMN:      id          (from product table)", 
            "title": "new O2MRelation(args)"
        }, 
        {
            "location": "/api/O2MRelation/#o2mrelationtype-relationtype", 
            "text": "Type of relation which is  ONE TO MANY .  Kind : instance property of  O2MRelation  Read only : true", 
            "title": "o2MRelation.type : relationType"
        }, 
        {
            "location": "/api/O2MRelation/#o2mrelationsourcetable-table", 
            "text": "Table  which this relation belongs to.  Kind : instance property of  O2MRelation  Read only : true  Example     let relation     = product.O2MRelationRelations[0];  // RELATION:    product ---  line_item\nlet sourceTable  = relation.sourceTable;             // TABLE:       product", 
            "title": "o2MRelation.sourceTable : Table"
        }, 
        {
            "location": "/api/O2MRelation/#o2mrelationtargettable-table", 
            "text": "Table  which this relation is referring to.  Kind : instance property of  O2MRelation  Read only : true  Example     let relation     = product.O2MRelationRelations[0];  // RELATION:    product ---  line_item\nlet targetTable  = relation.targetTable;             // TABLE:       line_item", 
            "title": "o2MRelation.targetTable : Table"
        }, 
        {
            "location": "/api/O2MRelation/#o2mrelationconstraint-table", 
            "text": "Foreign key  constraint  between  source table  and  target table .  Kind : instance property of  O2MRelation  Read only : true  Example     let relation     = product.O2MRelationRelations[0];  // RELATION:    product ---  line_item\nlet constraint   = relation.constraint;              // CONSTRAINT:           ^-- product_has_carts\nlet FKColumn     = relation.constraint.columns[0];   // COLUMN:      product_id (from line_item table)", 
            "title": "o2MRelation.constraint : Table"
        }, 
        {
            "location": "/api/O2MRelation/#o2mrelationgeneratenamestrategy-string", 
            "text": "(! EXPERIMENTAL) Returns name for relation using given strategy. Please see  Relation Names  for details.  Kind : instance method of  O2MRelation  Returns :  string  - - Relation name.  See :  Relation Names        Param  Type  Description      [strategy]  string  (simple, complex) Naming strategy to use.", 
            "title": "o2MRelation.generateName([strategy]) \u21d2 string"
        }, 
        {
            "location": "/api/PgStructure/", 
            "text": "pgStructure\n\n\n\n\npgStructure\n\n\nmodule.exports(pgOptions, [schemas], options)\n \u21d2 \nPromise.\nDb\n \u23cf\n\n\nstatic\n\n\n.save(file, db)\n \u21d2 \nPromise.\nstring\n\n\n.load(file)\n \u21d2 \nPromise.\n(Db\\|undefined)\n\n\n.serialize(db)\n \u21d2 \nstring\n\n\n.toString(db)\n \u21d2 \nstring\n\n\n.deserialize(serializedDbJSON)\n \u21d2 \nDb\n \n \nundefined\n\n\n.parse(serializedDb)\n \u21d2 \nDb\n \n \nundefined\n\n\n\n\n\n\ninner\n\n\n~pgOptions\n : \nObject\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmodule.exports(pgOptions, [schemas], options) \u21d2 \nPromise.\nDb\n \u23cf\n\n\nCreates and returns \nDb\n instance by reverse engineering PostgreSQL database.\n\n\nKind\n: Exported function\n\n\nReturns\n: \nPromise.\nDb\n - - \nDb\n.  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npgOptions\n\n\npgOptions\n \n \npg#client\n\n\n\n\nnode-postgres client or connection parameters. Parameters passed directly to node-postgres. See it for details.\n\n\n\n\n\n\n[schemas]\n\n\nstring\n \n \nArray.\nstring\n\n\n[\npublic\n]\n\n\nPostgreSQL schemas to be parsed.\n\n\n\n\n\n\noptions\n\n\nObject\n\n\n\n\npg-structure options.\n\n\n\n\n\n\n[options.cache]\n\n\nboolean\n\n\ntrue\n\n\nUse cache to memoize calculated results.\n\n\n\n\n\n\n\n\nExample\n  \n\n\nvar pgStructure = require('pg-structure');\n\npgStructure({database: 'db', user: 'user', password: 'password'}, ['public', 'other_schema'])\n    .then((db) =\n { console.log( db.get('public.account').columns[0].name ); })\n    .catch(err =\n console.log(err.stack));\n\n\n\n\n\n\nmodule.exports.save(file, db) \u21d2 \nPromise.\nstring\n\n\nSaves given database structure to a disk file. If given file name ends with \n.zip\n extension, file will be saved as\ncompressed zip file.\n\n\nKind\n: static method of \nmodule.exports\n\n\nReturns\n: \nPromise.\nstring\n - - Serialized string.  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nstring\n \n \nundefined\n\n\nFile path to save database structure.\n\n\n\n\n\n\ndb\n\n\nDb\n\n\nDb\n object to save.\n\n\n\n\n\n\n\n\nExample\n  \n\n\nvar pgStructure = require('pg-structure');\n\npgStructure({database: 'db', user: 'user', password: 'password', host: 'localhost', port: 5432}, ['public', 'other_schema'])\n    .then(db =\n pgStructure.save('./db.json', db))\n    .catch(err =\n console.log(err.stack));\n\n\n\n\n\n\nmodule.exports.load(file) \u21d2 \nPromise.\n(Db\\|undefined)\n\n\nLoads database structure from previously saved file. Much faster than getting structure from database.\nIf file is a zip file which contains a json file with same name as zip file, this function decompresses the file\nautomatically.\n\n\n pgStructure cannot\nload files saved by incompatible pg-structure module versions and returns \nundefined\n. In this case you should\nfetch structure from database and create a new save file.\n\n\nKind\n: static method of \nmodule.exports\n\n\nReturns\n: \nPromise.\n(Db\\|undefined)\n - - \nDb\n instance or \nundefined\n if saved file is generated with incompatible module version.  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nfile\n\n\nstring\n\n\nFile path to load db structure from.\n\n\n\n\n\n\n\n\nExample\n  \n\n\nvar pgStructure = require('pg-structure');\n\npgStructure.load('./db.json')\n    .then(db =\n console.log(db.schemas[0].name))\n    .catch(err =\n console.log(err.stack));\n\n\n\n\n\n\nmodule.exports.serialize(db) \u21d2 \nstring\n\n\nSerializes database structure to make it possible to store or transfer.\n\n\nKind\n: static method of \nmodule.exports\n\n\nReturns\n: \nstring\n - - Serialized database structure.  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndb\n\n\nDb\n\n\nDb\n instance to serialize.\n\n\n\n\n\n\n\n\nExample\n  \n\n\npgStructure({database: 'db', user: 'user', password: 'password', host: 'localhost', port: 5432}, ['public', 'other_schema'])\n    .then(db =\n pgStructure.serialize(db))\n    .then(data =\n console.log(data))\n    .catch(err =\n console.log(err.stack));\n\n\n\n\n\n\nmodule.exports.toString(db) \u21d2 \nstring\n\n\nAlias of {@link module:pgStructure.serialize). Serializes database structure to make it possible to store or transfer.\n\n\nKind\n: static method of \nmodule.exports\n\n\nReturns\n: \nstring\n - - Serialized database structure.\n\n\nSee\n: {@link module:pgStructure.serialize)  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndb\n\n\nDb\n\n\nDb\n instance to serialize.\n\n\n\n\n\n\n\n\n\n\nmodule.exports.deserialize(serializedDbJSON) \u21d2 \nDb\n \n \nundefined\n\n\nCreates and returns \nDb\n instance using previously serialized string. \n\n\n pgStructure cannot\ndeserialize incompatible pg-structure module versions and returns \nundefined\n. In this case you should fetch structure from database.\n\n\nKind\n: static method of \nmodule.exports\n\n\nReturns\n: \nDb\n \n \nundefined\n - - \nDb\n instance. If serialized string is from incompatible module version, this is \nundefined\n\nvar pgStructure = require('pg-structure');\n\n\npgStructure.deserialize('./db.json')\n    .then(db =\n console.log(db.schemas[0].name)\n    .catch(err =\n console.log(err.stack));  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nserializedDbJSON\n\n\nstring\n\n\nSerialized database structure to create \nDb\n instance from.\n\n\n\n\n\n\n\n\n\n\nmodule.exports.parse(serializedDb) \u21d2 \nDb\n \n \nundefined\n\n\nAlias of \ndeserialize\n. Creates and returns \nDb\n instance using previously serialized string. \n\n\n pgStructure cannot\ndeserialize incompatible pg-structure module versions and returns \nundefined\n. In this case you should fetch structure from database.\n\n\nKind\n: static method of \nmodule.exports\n\n\nReturns\n: \nDb\n \n \nundefined\n - - \nDb\n instance. If serialized string is from incompatible module version, this is \nundefined\n\n\nSee\n: \ndeserialize\n  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nserializedDb\n\n\nstring\n\n\nSerialized database structure to create \nDb\n instance from.\n\n\n\n\n\n\n\n\n\n\nmodule.exports~pgOptions : \nObject\n\n\nPostgreSQL connection options which are passed directly to node-postgres.\n\n\nKind\n: inner typedef of \nmodule.exports\n\n\nProperties\n\n\n\n\n\n\n\n\nName\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndatabase\n\n\nstring\n\n\n\n\nDatabase name\n\n\n\n\n\n\nhost\n\n\nstring\n\n\nlocalhost\n\n\nHostname of the database.\n\n\n\n\n\n\nport\n\n\nnumber\n\n\n5432\n\n\nPort of the database.\n\n\n\n\n\n\nuser\n\n\nstring\n\n\n\n\nUsername for connecting to db.\n\n\n\n\n\n\npassword\n\n\nstring\n\n\n\n\nPassword to connecting to db.\n\n\n\n\n\n\nssl\n\n\nboolean\n \n \nObject\n\n\nfalse\n\n\nPass the same options as tls.connect().", 
            "title": "pgStructure"
        }, 
        {
            "location": "/api/PgStructure/#pgstructure", 
            "text": "pgStructure  module.exports(pgOptions, [schemas], options)  \u21d2  Promise. Db  \u23cf  static  .save(file, db)  \u21d2  Promise. string  .load(file)  \u21d2  Promise. (Db\\|undefined)  .serialize(db)  \u21d2  string  .toString(db)  \u21d2  string  .deserialize(serializedDbJSON)  \u21d2  Db     undefined  .parse(serializedDb)  \u21d2  Db     undefined    inner  ~pgOptions  :  Object", 
            "title": "pgStructure"
        }, 
        {
            "location": "/api/PgStructure/#moduleexportspgoptions-schemas-options-promisedb", 
            "text": "Creates and returns  Db  instance by reverse engineering PostgreSQL database.  Kind : Exported function  Returns :  Promise. Db  - -  Db .       Param  Type  Default  Description      pgOptions  pgOptions     pg#client   node-postgres client or connection parameters. Parameters passed directly to node-postgres. See it for details.    [schemas]  string     Array. string  [ public ]  PostgreSQL schemas to be parsed.    options  Object   pg-structure options.    [options.cache]  boolean  true  Use cache to memoize calculated results.     Example     var pgStructure = require('pg-structure');\n\npgStructure({database: 'db', user: 'user', password: 'password'}, ['public', 'other_schema'])\n    .then((db) =  { console.log( db.get('public.account').columns[0].name ); })\n    .catch(err =  console.log(err.stack));", 
            "title": "module.exports(pgOptions, [schemas], options) \u21d2 Promise.&lt;Db&gt; \u23cf"
        }, 
        {
            "location": "/api/PgStructure/#moduleexportssavefile-db-promisestring", 
            "text": "Saves given database structure to a disk file. If given file name ends with  .zip  extension, file will be saved as\ncompressed zip file.  Kind : static method of  module.exports  Returns :  Promise. string  - - Serialized string.       Param  Type  Description      file  string     undefined  File path to save database structure.    db  Db  Db  object to save.     Example     var pgStructure = require('pg-structure');\n\npgStructure({database: 'db', user: 'user', password: 'password', host: 'localhost', port: 5432}, ['public', 'other_schema'])\n    .then(db =  pgStructure.save('./db.json', db))\n    .catch(err =  console.log(err.stack));", 
            "title": "module.exports.save(file, db) \u21d2 Promise.&lt;string&gt;"
        }, 
        {
            "location": "/api/PgStructure/#moduleexportsloadfile-promisedbundefined", 
            "text": "Loads database structure from previously saved file. Much faster than getting structure from database.\nIf file is a zip file which contains a json file with same name as zip file, this function decompresses the file\nautomatically.   pgStructure cannot\nload files saved by incompatible pg-structure module versions and returns  undefined . In this case you should\nfetch structure from database and create a new save file.  Kind : static method of  module.exports  Returns :  Promise. (Db\\|undefined)  - -  Db  instance or  undefined  if saved file is generated with incompatible module version.       Param  Type  Description      file  string  File path to load db structure from.     Example     var pgStructure = require('pg-structure');\n\npgStructure.load('./db.json')\n    .then(db =  console.log(db.schemas[0].name))\n    .catch(err =  console.log(err.stack));", 
            "title": "module.exports.load(file) \u21d2 Promise.&lt;(Db\\|undefined)&gt;"
        }, 
        {
            "location": "/api/PgStructure/#moduleexportsserializedb-string", 
            "text": "Serializes database structure to make it possible to store or transfer.  Kind : static method of  module.exports  Returns :  string  - - Serialized database structure.       Param  Type  Description      db  Db  Db  instance to serialize.     Example     pgStructure({database: 'db', user: 'user', password: 'password', host: 'localhost', port: 5432}, ['public', 'other_schema'])\n    .then(db =  pgStructure.serialize(db))\n    .then(data =  console.log(data))\n    .catch(err =  console.log(err.stack));", 
            "title": "module.exports.serialize(db) \u21d2 string"
        }, 
        {
            "location": "/api/PgStructure/#moduleexportstostringdb-string", 
            "text": "Alias of {@link module:pgStructure.serialize). Serializes database structure to make it possible to store or transfer.  Kind : static method of  module.exports  Returns :  string  - - Serialized database structure.  See : {@link module:pgStructure.serialize)       Param  Type  Description      db  Db  Db  instance to serialize.", 
            "title": "module.exports.toString(db) \u21d2 string"
        }, 
        {
            "location": "/api/PgStructure/#moduleexportsdeserializeserializeddbjson-db-undefined", 
            "text": "Creates and returns  Db  instance using previously serialized string.    pgStructure cannot\ndeserialize incompatible pg-structure module versions and returns  undefined . In this case you should fetch structure from database.  Kind : static method of  module.exports  Returns :  Db     undefined  - -  Db  instance. If serialized string is from incompatible module version, this is  undefined \nvar pgStructure = require('pg-structure');  pgStructure.deserialize('./db.json')\n    .then(db =  console.log(db.schemas[0].name)\n    .catch(err =  console.log(err.stack));       Param  Type  Description      serializedDbJSON  string  Serialized database structure to create  Db  instance from.", 
            "title": "module.exports.deserialize(serializedDbJSON) \u21d2 Db &#124; undefined"
        }, 
        {
            "location": "/api/PgStructure/#moduleexportsparseserializeddb-db-undefined", 
            "text": "Alias of  deserialize . Creates and returns  Db  instance using previously serialized string.    pgStructure cannot\ndeserialize incompatible pg-structure module versions and returns  undefined . In this case you should fetch structure from database.  Kind : static method of  module.exports  Returns :  Db     undefined  - -  Db  instance. If serialized string is from incompatible module version, this is  undefined  See :  deserialize        Param  Type  Description      serializedDb  string  Serialized database structure to create  Db  instance from.", 
            "title": "module.exports.parse(serializedDb) \u21d2 Db &#124; undefined"
        }, 
        {
            "location": "/api/PgStructure/#moduleexportspgoptions-object", 
            "text": "PostgreSQL connection options which are passed directly to node-postgres.  Kind : inner typedef of  module.exports  Properties     Name  Type  Default  Description      database  string   Database name    host  string  localhost  Hostname of the database.    port  number  5432  Port of the database.    user  string   Username for connecting to db.    password  string   Password to connecting to db.    ssl  boolean     Object  false  Pass the same options as tls.connect().", 
            "title": "module.exports~pgOptions : Object"
        }, 
        {
            "location": "/api/Schema/", 
            "text": "Schema\n\n\nClass which represent a PostgreSQL schema. Provides attributes and methods for details of the database.\n\n\nKind\n: global class  \n\n\n\n\nSchema\n\n\nnew Schema(args)\n\n\n.name\n : \nstring\n\n\n.fullName\n : \nstring\n\n\n.fullCatalogName\n : \nstring\n\n\n.db\n : \nDb\n\n\n.parent\n : \nDb\n\n\n.tables\n : \nMap.\nTable\n\n\n.get(path)\n \u21d2 \nTable\n \n \nColumn\n \n \nundefined\n\n\n\n\n\n\n\n\n\n\nnew Schema(args)\n\n\nConstructor function. You don't need to call constructor manually. pg-structure handles this.\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nargs\n\n\nObject\n\n\nAttributes of the \nSchema\n instance to be created.\n\n\n\n\n\n\nargs.parent\n\n\nDb\n\n\nParent \nDb\n of the Schema.\n\n\n\n\n\n\nargs.name\n\n\nstring\n\n\nName of the Schema.\n\n\n\n\n\n\n\n\n\n\nschema.name : \nstring\n\n\nName of the schema.\n\n\nKind\n: instance property of \nSchema\n\n\nRead only\n: true\n\n\n\n\nschema.fullName : \nstring\n\n\nFull name of the \nSchema\n. For schema it is equal to schema name.\n\n\nKind\n: instance property of \nSchema\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nvar fullName = schema.fullName; // public\n\n\n\n\n\n\nschema.fullCatalogName : \nstring\n\n\nFull name of the \nSchema\n with (.) notation including catalog name.\n\n\nKind\n: instance property of \nSchema\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nvar fullCatalogName = schema.fullCatalogName; // crm.public\n\n\n\n\n\n\nschema.db : \nDb\n\n\nDb\n this schema belongs to.\n\n\nKind\n: instance property of \nSchema\n\n\nRead only\n: true\n\n\nSee\n: Aliases \nparent\n\n\nExample\n  \n\n\nvar db = schema.db; // Db instance\n\n\n\n\n\n\nschema.parent : \nDb\n\n\nDb\n this schema belongs to.\n\n\nKind\n: instance property of \nSchema\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ndb\n\n\nExample\n  \n\n\nvar db = schema.parent; // Db instance\n\n\n\n\n\n\nschema.tables : \nMap.\nTable\n\n\nAll \nTable\n instances of the schema as a \nMap\n. They are ordered by their name.\n\n\nKind\n: instance property of \nSchema\n\n\nRead only\n: true\n\n\nSee\n: \nMap\n\n\nExample\n  \n\n\nlet isAvailable  = schema.tables.has('person');\nlet tableNames   = Array.from(schema.tables.keys());        // Use spread operator to get table names as an array.\nlet table        = schema.tables.get('account');\nlet name         = table.name;\n\nfor (let table of schema.tables.values()) {\n    console.log(table.name);\n}\n\nfor (let [name, table] of schema.tables) {\n    console.log(name, table.name);\n}\n\n\n\n\n\n\nschema.get(path) \u21d2 \nTable\n \n \nColumn\n \n \nundefined\n\n\nReturns \nTable\n or \nColumn\n on given path relative to \nSchema\n. Path should be in dot (.) notation.\n\n\nKind\n: instance method of \nSchema\n\n\nReturns\n: \nTable\n \n \nColumn\n \n \nundefined\n - - Requested item.  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nstring\n\n\nPath of the requested item in dot (.) notation such as 'public.contact'\n\n\n\n\n\n\n\n\nExample\n  \n\n\nvar table  = db.get('contact'),      // Returns contact table in public schema.\n    column = db.get('contact.name'); // Returns name column of the contact table.", 
            "title": "Schema"
        }, 
        {
            "location": "/api/Schema/#schema", 
            "text": "Class which represent a PostgreSQL schema. Provides attributes and methods for details of the database.  Kind : global class     Schema  new Schema(args)  .name  :  string  .fullName  :  string  .fullCatalogName  :  string  .db  :  Db  .parent  :  Db  .tables  :  Map. Table  .get(path)  \u21d2  Table     Column     undefined", 
            "title": "Schema"
        }, 
        {
            "location": "/api/Schema/#new-schemaargs", 
            "text": "Constructor function. You don't need to call constructor manually. pg-structure handles this.     Param  Type  Description      args  Object  Attributes of the  Schema  instance to be created.    args.parent  Db  Parent  Db  of the Schema.    args.name  string  Name of the Schema.", 
            "title": "new Schema(args)"
        }, 
        {
            "location": "/api/Schema/#schemaname-string", 
            "text": "Name of the schema.  Kind : instance property of  Schema  Read only : true", 
            "title": "schema.name : string"
        }, 
        {
            "location": "/api/Schema/#schemafullname-string", 
            "text": "Full name of the  Schema . For schema it is equal to schema name.  Kind : instance property of  Schema  Read only : true  Example     var fullName = schema.fullName; // public", 
            "title": "schema.fullName : string"
        }, 
        {
            "location": "/api/Schema/#schemafullcatalogname-string", 
            "text": "Full name of the  Schema  with (.) notation including catalog name.  Kind : instance property of  Schema  Read only : true  Example     var fullCatalogName = schema.fullCatalogName; // crm.public", 
            "title": "schema.fullCatalogName : string"
        }, 
        {
            "location": "/api/Schema/#schemadb-db", 
            "text": "Db  this schema belongs to.  Kind : instance property of  Schema  Read only : true  See : Aliases  parent  Example     var db = schema.db; // Db instance", 
            "title": "schema.db : Db"
        }, 
        {
            "location": "/api/Schema/#schemaparent-db", 
            "text": "Db  this schema belongs to.  Kind : instance property of  Schema  Read only : true  See : Aliases  db  Example     var db = schema.parent; // Db instance", 
            "title": "schema.parent : Db"
        }, 
        {
            "location": "/api/Schema/#schematables-maptable", 
            "text": "All  Table  instances of the schema as a  Map . They are ordered by their name.  Kind : instance property of  Schema  Read only : true  See :  Map  Example     let isAvailable  = schema.tables.has('person');\nlet tableNames   = Array.from(schema.tables.keys());        // Use spread operator to get table names as an array.\nlet table        = schema.tables.get('account');\nlet name         = table.name;\n\nfor (let table of schema.tables.values()) {\n    console.log(table.name);\n}\n\nfor (let [name, table] of schema.tables) {\n    console.log(name, table.name);\n}", 
            "title": "schema.tables : Map.&lt;Table&gt;"
        }, 
        {
            "location": "/api/Schema/#schemagetpath-table-column-undefined", 
            "text": "Returns  Table  or  Column  on given path relative to  Schema . Path should be in dot (.) notation.  Kind : instance method of  Schema  Returns :  Table     Column     undefined  - - Requested item.       Param  Type  Description      path  string  Path of the requested item in dot (.) notation such as 'public.contact'     Example     var table  = db.get('contact'),      // Returns contact table in public schema.\n    column = db.get('contact.name'); // Returns name column of the contact table.", 
            "title": "schema.get(path) \u21d2 Table &#124; Column &#124; undefined"
        }, 
        {
            "location": "/api/Table/", 
            "text": "Table\n\n\nClass which represent a table. Provides attributes and methods for details of the table. Tables have relationships\nwith other tables.\n\n\nBelow is a database schema which is used in code examples.\n\n\nsize -------------------\nid (PK)                |  ---------------------------\n line_item \n------------ cart\nname                   |  |                            product_id (PFK)        id (PK)\n                       |  |                            cart_id    (PFK)        name\n                       ^  |\ncolor -------------\n product \n------------- vendor\nid (PK)              id        (PK)         id (PK)\nname                 name                   name\n                     color_id  (FK)\n                     size_id   (FK)\n                     vendor_id (FK)\n\n\n\n\nBelow is the same schema as image:\n\n\n\nKind\n: global class  \n\n\n\n\nTable\n\n\nnew Table(args)\n\n\n.name\n : \nstring\n\n\n.fullName\n : \nstring\n\n\n.fullCatalogName\n : \nstring\n\n\n.schema\n : \nSchema\n\n\n.parent\n : \nSchema\n\n\n.comment\n : \nstring\n\n\n.commentData\n : \nObject\n\n\n.description\n : \nstring\n\n\n.descriptionData\n : \nObject\n\n\n.columns\n : \nMap.\nColumn\n\n\n.constraints\n : \nMap.\nConstraint\n\n\n.db\n : \nDb\n\n\n.foreignKeyConstraints\n : \nMap.\nConstraint\n\n\n.foreignKeyColumns\n : \nMap.\nColumn\n\n\n.foreignKeyConstraintsToThis\n : \nMap.\nConstraint\n\n\n.primaryKeyConstraint\n : \nConstraint\n \n \nundefined\n\n\n.primaryKeyColumns\n : \nMap.\nColumn\n\n\n.hasManyTables\n : \nMap.\nTable\n\n\n.belongsToTables\n : \nMap.\nTable\n\n\n.belongsToManyTables\n : \nMap.\nTable\n\n\n.belongsToManyTablesPk\n : \nMap.\nTable\n\n\n.m2mRelations\n : \nSet.\nM2MRelation\n\n\n.m2mRelationsPk\n : \nSet.\nM2MRelation\n\n\n.o2mRelations\n : \nSet.\nO2MRelation\n\n\n.m2oRelations\n : \nSet.\nM2ORelation\n\n\n.relations\n : \nArray.\n(O2MRelation\\|M2ORelation\\|M2MRelation)\n\n\n.get(path)\n \u21d2 \nColumn\n \n \nundefined\n\n\n\n\n\n\n\n\n\n\nnew Table(args)\n\n\nConstructor function. You don't need to call constructor manually. pg-structure handles this.\n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nargs\n\n\nObject\n\n\nAttributes of the \nTable\n instance to be created.\n\n\n\n\n\n\nargs.parent\n\n\nSchema\n\n\nParent \nSchema\n of the Table.\n\n\n\n\n\n\nargs.name\n\n\nstring\n\n\nName of the Table.\n\n\n\n\n\n\nargs.description\n\n\nstring\n\n\nDescription of the Table.\n\n\n\n\n\n\nargs.descriptionData\n\n\nObject\n\n\nExtra data to store in object.\n\n\n\n\n\n\n\n\n\n\ntable.name : \nstring\n\n\nName of the table.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\n\n\ntable.fullName : \nstring\n\n\nFull name of the \nTable\n with (.) notation.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nvar fullName = table.fullName; // public.account\n\n\n\n\n\n\ntable.fullCatalogName : \nstring\n\n\nFull name of the \nTable\n with (.) notation including catalog name.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nExample\n  \n\n\nvar fullName = table.fullName; // crm.public.account\n\n\n\n\n\n\ntable.schema : \nSchema\n\n\nSchema\n this table belongs to.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: Aliases \nparent\n\n\nExample\n  \n\n\nvar schema = table.schema; // Schema instance\n\n\n\n\n\n\ntable.parent : \nSchema\n\n\nSchema\n this table belongs to.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: Aliases \nschema\n\n\nExample\n  \n\n\nvar schema = table.parent; // Schema instance\n\n\n\n\n\n\ntable.comment : \nstring\n\n\nComment of the table.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ndescription\n\n\n\n\ntable.commentData : \nObject\n\n\nJS Object extracted from table description. Object is expected as JSON data between \n[PG-STRUCTURE]\n and \n[/PG-STRUCTURE]\n\ntags in description. Tags are case-insensitive.\nFor maximum comfort JSON parsing is made by \njsonic\n. It is a non-strict JSON parser. It is possible\nto ommit quotes etc. Please see \njsonic\n for details.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ndescriptionData\n\n\nExample\n  \n\n\nlet description = table.comment;             // -\n 'This table holds account details. [PG-STRUCTURE]{ extraData: 2 }[/PGEN]'\nlet extra = table.commentData;               // -\n { extraData: 2 }\nconsole.log(table.commentData.extraData);    // -\n 2\n\n\n\n\n\n\ntable.description : \nstring\n\n\nComment of the table.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ncomment\n\n\n\n\ntable.descriptionData : \nObject\n\n\nJS Object extracted from table description. Object is expected as JSON data between \n[PG-STRUCTURE]\n and \n[/PG-STRUCTURE]\n\ntags in description. Tags are case-insensitive.\nFor maximum comfort JSON parsing is made by \njsonic\n. It is a non-strict JSON parser. It is possible\nto ommit quotes etc.\n\n You don't need to quote property names: { foo:\"bar baz\", red:255 }\n\n You don't need the top level braces: foo:\"bar baz\", red:255\n\n You don't need to quote strings with spaces: foo:bar baz, red:255\n\n You do need to quote strings if they contain a comma or closing brace or square bracket: icky:\",}]\"\n\n You can use single quotes for strings: Jules:'Cry \"Havoc,\" and let slip the dogs of war!'\n\n You can have trailing commas: foo:bar, red:255,\nFor details, please see \njsonic\n.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: Aliases \ncommentData\n\n\nExample\n  \n\n\nlet description = table.description;             // -\n 'This table holds account details. [PG-STRUCTURE]{ \nextraData\n: 2 }[/PGEN]'\nlet extra = table.descriptionData;               // -\n { extraData: 2 }\nconsole.log(table.descriptionData.extraData);    // -\n 2\n\n\n\n\n\n\ntable.columns : \nMap.\nColumn\n\n\nAll \nColumn\n instances in the table as a \nMap\n. They are ordered same order as they are\ndefined in database table.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: \nMap\n\n\nExample\n  \n\n\nvar isAvailable  = table.columns.has('id');\nvar columnNames  = Array.from(schema.columns.keys());       // Use spread operator to get column names as an array.\nvar column       = table.columns.get('user_id');\nvar name         = column.name;\n\nfor (let column of table.columns.values()) {\n    console.log(column.name);\n}\n\nfor (let [name, column] of table.columns) {\n    console.log(name, column.name);\n}\n\n\n\n\n\n\ntable.constraints : \nMap.\nConstraint\n\n\nAll \nConstraint\n instances in the table as a \nMap\n. They are ordered by name.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\n\n\ntable.db : \nDb\n\n\nDb\n this table belongs to.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\n\n\ntable.foreignKeyConstraints : \nMap.\nConstraint\n\n\nAll \nConstraint\n instances which are foreign key constraints in the table as a \nMap\n.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: \no2mRelations\n, \nm2oRelations\n, \nm2mRelations\n to get more details about relations.\n\n\n\n\ntable.foreignKeyColumns : \nMap.\nColumn\n\n\nAll foreign key \ncolumns\n of all \nforeignKeyConstraints\n as a \nMap\n.\nForeign key \nconstraints\n may contain more than one column. To get foreign key columns of a specific foreign key constraint\nuse \nforeignKeyConstraints\n.\ncolumns\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\n\n\ntable.foreignKeyConstraintsToThis : \nMap.\nConstraint\n\n\nAll foreign key \nConstraint\n instances which are referring to this table as a \nMap\n.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: \no2mRelations\n, \nm2oRelations\n, \nm2mRelations\n to get more details about relations.\n\n\n\n\ntable.primaryKeyConstraint : \nConstraint\n \n \nundefined\n\n\nPrimary key \nconstraint\n instance of this table.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: \nprimaryKeyColumns\n to get primary key columns directly.\n\n\nExample\n  \n\n\nlet pkConstraint = table.primaryKeyConstraint;\nlet pkColumns    = Array.from(pkConstraint.columns.values());   // As an array\n\nfor (let [name, column] of pkConstraint.columns) {\n    console.log(column.name);\n}\n\n\n\n\n\n\ntable.primaryKeyColumns : \nMap.\nColumn\n\n\nPrimary key \ncolumns\n of this table as a \nMap\n.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: \nprimaryKeyConstraint\n to get primary key constraint.\n\n\nExample\n  \n\n\nlet pkColumns  = Array.from(table.primaryKeyColumns.values());  // As an array\nfor (let [name, column] of pkConstraint.columns) {\n    console.log(column.name);\n}\n\n\n\n\n\n\ntable.hasManyTables : \nMap.\nTable\n\n\nTables\n sorted by name, which this table has relationship of type \none to many\n.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: \nExample schema\n, \nMap\n\n\nExample\n  \n\n\nfor (let [name, table] of vendorTable.hasManyTables) {\n    console.log(table.name);\n}\n\n\n\n\n\n\ntable.belongsToTables : \nMap.\nTable\n\n\nTables\n sorted by name, which this table has relationship of type \nbelongs to\n which is reverse direction of \none to many\n.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: \nExample schema\n, \nMap\n\n\nExample\n  \n\n\nfor (let [name, table] of productTable.belongsToTables) {\n    console.log(table.name);\n}\n\n\n\n\n\n\ntable.belongsToManyTables : \nMap.\nTable\n\n\nTables\n sorted by name, which this table has relationship of type \nmany to many\n.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: \nExample schema\n, \nMap\n\n\nExample\n  \n\n\n// Cart (id) has many products (id) through line_item join table.\nfor (let [name, table] of cartTable.belongsToManyTables) {\n    console.log(table.name);\n}\n\n\n\n\n\n\ntable.belongsToManyTablesPk : \nMap.\nTable\n\n\nTables\n sorted by name, which this table has relationship of type \nmany to many\n. Includes\nonly tables joined by primary keys in join table.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\nSee\n: \nExample schema\n, \nMap\n\n\nExample\n  \n\n\n// Cart (id) has many products (id) through line_item join table.\nfor (let [name, table] of cartTable.belongsToManyTables) {\n    console.log(table.name);\n}\n\n\n\n\n\n\ntable.m2mRelations : \nSet.\nM2MRelation\n\n\nSet of \nmany to many relationships\n of the table. \nM2MRelation\n resembles\n\nhas many through\n and \nbelongs to many\n relations in ORMs. It has some useful methods and information for generating ORM classes.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\n\n\ntable.m2mRelationsPk : \nSet.\nM2MRelation\n\n\nSet of \nmany to many relationships\n of the table. Different from \nm2mRelations\n\nthis only includes relations joined by \nPrimary Foreign Keys\n in join table. \nPrimary Foreign Keys\n means\nforeign keys of join table which are also Primary Keys of join table at the same time.\n\nM2MRelation\n resembles \nhas many through\n and \nbelongs to many\n relations in ORMs.\nIt has some useful methods and information for generating ORM classes.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\n\n\ntable.o2mRelations : \nSet.\nO2MRelation\n\n\nSet of \none to many relationships\n of the table. \nO2MRelation\n resembles\n\nhas many\n relations in ORMs. It has some useful methods and information for generating ORM classes.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\n\n\ntable.m2oRelations : \nSet.\nM2ORelation\n\n\nSet of \nmany to one relationships\n of the table. \nM2ORelation\n resembles\n\nbelongs to\n relations in ORMs. It has some useful methods and information for generating ORM classes.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\n\n\ntable.relations : \nArray.\n(O2MRelation\\|M2ORelation\\|M2MRelation)\n\n\nList of all relationships of the table.\n\n\nKind\n: instance property of \nTable\n\n\nRead only\n: true\n\n\n\n\ntable.get(path) \u21d2 \nColumn\n \n \nundefined\n\n\nReturns \nColumn\n on given path relative to \nTable\n.\n\n\nKind\n: instance method of \nTable\n\n\nReturns\n: \nColumn\n \n \nundefined\n - - Requested item.  \n\n\n\n\n\n\n\n\nParam\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nstring\n\n\nPath of the requested item in dot (.) notation such as 'public.contact'\n\n\n\n\n\n\n\n\nExample\n  \n\n\nvar column = table.get('contact'),      // Returns contact column in public table.", 
            "title": "Table"
        }, 
        {
            "location": "/api/Table/#table", 
            "text": "Class which represent a table. Provides attributes and methods for details of the table. Tables have relationships\nwith other tables.  Below is a database schema which is used in code examples.  size -------------------\nid (PK)                |  ---------------------------  line_item  ------------ cart\nname                   |  |                            product_id (PFK)        id (PK)\n                       |  |                            cart_id    (PFK)        name\n                       ^  |\ncolor -------------  product  ------------- vendor\nid (PK)              id        (PK)         id (PK)\nname                 name                   name\n                     color_id  (FK)\n                     size_id   (FK)\n                     vendor_id (FK)  Below is the same schema as image:  Kind : global class     Table  new Table(args)  .name  :  string  .fullName  :  string  .fullCatalogName  :  string  .schema  :  Schema  .parent  :  Schema  .comment  :  string  .commentData  :  Object  .description  :  string  .descriptionData  :  Object  .columns  :  Map. Column  .constraints  :  Map. Constraint  .db  :  Db  .foreignKeyConstraints  :  Map. Constraint  .foreignKeyColumns  :  Map. Column  .foreignKeyConstraintsToThis  :  Map. Constraint  .primaryKeyConstraint  :  Constraint     undefined  .primaryKeyColumns  :  Map. Column  .hasManyTables  :  Map. Table  .belongsToTables  :  Map. Table  .belongsToManyTables  :  Map. Table  .belongsToManyTablesPk  :  Map. Table  .m2mRelations  :  Set. M2MRelation  .m2mRelationsPk  :  Set. M2MRelation  .o2mRelations  :  Set. O2MRelation  .m2oRelations  :  Set. M2ORelation  .relations  :  Array. (O2MRelation\\|M2ORelation\\|M2MRelation)  .get(path)  \u21d2  Column     undefined", 
            "title": "Table"
        }, 
        {
            "location": "/api/Table/#new-tableargs", 
            "text": "Constructor function. You don't need to call constructor manually. pg-structure handles this.     Param  Type  Description      args  Object  Attributes of the  Table  instance to be created.    args.parent  Schema  Parent  Schema  of the Table.    args.name  string  Name of the Table.    args.description  string  Description of the Table.    args.descriptionData  Object  Extra data to store in object.", 
            "title": "new Table(args)"
        }, 
        {
            "location": "/api/Table/#tablename-string", 
            "text": "Name of the table.  Kind : instance property of  Table  Read only : true", 
            "title": "table.name : string"
        }, 
        {
            "location": "/api/Table/#tablefullname-string", 
            "text": "Full name of the  Table  with (.) notation.  Kind : instance property of  Table  Read only : true  Example     var fullName = table.fullName; // public.account", 
            "title": "table.fullName : string"
        }, 
        {
            "location": "/api/Table/#tablefullcatalogname-string", 
            "text": "Full name of the  Table  with (.) notation including catalog name.  Kind : instance property of  Table  Read only : true  Example     var fullName = table.fullName; // crm.public.account", 
            "title": "table.fullCatalogName : string"
        }, 
        {
            "location": "/api/Table/#tableschema-schema", 
            "text": "Schema  this table belongs to.  Kind : instance property of  Table  Read only : true  See : Aliases  parent  Example     var schema = table.schema; // Schema instance", 
            "title": "table.schema : Schema"
        }, 
        {
            "location": "/api/Table/#tableparent-schema", 
            "text": "Schema  this table belongs to.  Kind : instance property of  Table  Read only : true  See : Aliases  schema  Example     var schema = table.parent; // Schema instance", 
            "title": "table.parent : Schema"
        }, 
        {
            "location": "/api/Table/#tablecomment-string", 
            "text": "Comment of the table.  Kind : instance property of  Table  Read only : true  See : Aliases  description", 
            "title": "table.comment : string"
        }, 
        {
            "location": "/api/Table/#tablecommentdata-object", 
            "text": "JS Object extracted from table description. Object is expected as JSON data between  [PG-STRUCTURE]  and  [/PG-STRUCTURE] \ntags in description. Tags are case-insensitive.\nFor maximum comfort JSON parsing is made by  jsonic . It is a non-strict JSON parser. It is possible\nto ommit quotes etc. Please see  jsonic  for details.  Kind : instance property of  Table  Read only : true  See : Aliases  descriptionData  Example     let description = table.comment;             // -  'This table holds account details. [PG-STRUCTURE]{ extraData: 2 }[/PGEN]'\nlet extra = table.commentData;               // -  { extraData: 2 }\nconsole.log(table.commentData.extraData);    // -  2", 
            "title": "table.commentData : Object"
        }, 
        {
            "location": "/api/Table/#tabledescription-string", 
            "text": "Comment of the table.  Kind : instance property of  Table  Read only : true  See : Aliases  comment", 
            "title": "table.description : string"
        }, 
        {
            "location": "/api/Table/#tabledescriptiondata-object", 
            "text": "JS Object extracted from table description. Object is expected as JSON data between  [PG-STRUCTURE]  and  [/PG-STRUCTURE] \ntags in description. Tags are case-insensitive.\nFor maximum comfort JSON parsing is made by  jsonic . It is a non-strict JSON parser. It is possible\nto ommit quotes etc.  You don't need to quote property names: { foo:\"bar baz\", red:255 }  You don't need the top level braces: foo:\"bar baz\", red:255  You don't need to quote strings with spaces: foo:bar baz, red:255  You do need to quote strings if they contain a comma or closing brace or square bracket: icky:\",}]\"  You can use single quotes for strings: Jules:'Cry \"Havoc,\" and let slip the dogs of war!'  You can have trailing commas: foo:bar, red:255,\nFor details, please see  jsonic .  Kind : instance property of  Table  Read only : true  See : Aliases  commentData  Example     let description = table.description;             // -  'This table holds account details. [PG-STRUCTURE]{  extraData : 2 }[/PGEN]'\nlet extra = table.descriptionData;               // -  { extraData: 2 }\nconsole.log(table.descriptionData.extraData);    // -  2", 
            "title": "table.descriptionData : Object"
        }, 
        {
            "location": "/api/Table/#tablecolumns-mapcolumn", 
            "text": "All  Column  instances in the table as a  Map . They are ordered same order as they are\ndefined in database table.  Kind : instance property of  Table  Read only : true  See :  Map  Example     var isAvailable  = table.columns.has('id');\nvar columnNames  = Array.from(schema.columns.keys());       // Use spread operator to get column names as an array.\nvar column       = table.columns.get('user_id');\nvar name         = column.name;\n\nfor (let column of table.columns.values()) {\n    console.log(column.name);\n}\n\nfor (let [name, column] of table.columns) {\n    console.log(name, column.name);\n}", 
            "title": "table.columns : Map.&lt;Column&gt;"
        }, 
        {
            "location": "/api/Table/#tableconstraints-mapconstraint", 
            "text": "All  Constraint  instances in the table as a  Map . They are ordered by name.  Kind : instance property of  Table  Read only : true", 
            "title": "table.constraints : Map.&lt;Constraint&gt;"
        }, 
        {
            "location": "/api/Table/#tabledb-db", 
            "text": "Db  this table belongs to.  Kind : instance property of  Table  Read only : true", 
            "title": "table.db : Db"
        }, 
        {
            "location": "/api/Table/#tableforeignkeyconstraints-mapconstraint", 
            "text": "All  Constraint  instances which are foreign key constraints in the table as a  Map .  Kind : instance property of  Table  Read only : true  See :  o2mRelations ,  m2oRelations ,  m2mRelations  to get more details about relations.", 
            "title": "table.foreignKeyConstraints : Map.&lt;Constraint&gt;"
        }, 
        {
            "location": "/api/Table/#tableforeignkeycolumns-mapcolumn", 
            "text": "All foreign key  columns  of all  foreignKeyConstraints  as a  Map .\nForeign key  constraints  may contain more than one column. To get foreign key columns of a specific foreign key constraint\nuse  foreignKeyConstraints . columns  Kind : instance property of  Table  Read only : true", 
            "title": "table.foreignKeyColumns : Map.&lt;Column&gt;"
        }, 
        {
            "location": "/api/Table/#tableforeignkeyconstraintstothis-mapconstraint", 
            "text": "All foreign key  Constraint  instances which are referring to this table as a  Map .  Kind : instance property of  Table  Read only : true  See :  o2mRelations ,  m2oRelations ,  m2mRelations  to get more details about relations.", 
            "title": "table.foreignKeyConstraintsToThis : Map.&lt;Constraint&gt;"
        }, 
        {
            "location": "/api/Table/#tableprimarykeyconstraint-constraint-undefined", 
            "text": "Primary key  constraint  instance of this table.  Kind : instance property of  Table  Read only : true  See :  primaryKeyColumns  to get primary key columns directly.  Example     let pkConstraint = table.primaryKeyConstraint;\nlet pkColumns    = Array.from(pkConstraint.columns.values());   // As an array\n\nfor (let [name, column] of pkConstraint.columns) {\n    console.log(column.name);\n}", 
            "title": "table.primaryKeyConstraint : Constraint &#124; undefined"
        }, 
        {
            "location": "/api/Table/#tableprimarykeycolumns-mapcolumn", 
            "text": "Primary key  columns  of this table as a  Map .  Kind : instance property of  Table  Read only : true  See :  primaryKeyConstraint  to get primary key constraint.  Example     let pkColumns  = Array.from(table.primaryKeyColumns.values());  // As an array\nfor (let [name, column] of pkConstraint.columns) {\n    console.log(column.name);\n}", 
            "title": "table.primaryKeyColumns : Map.&lt;Column&gt;"
        }, 
        {
            "location": "/api/Table/#tablehasmanytables-maptable", 
            "text": "Tables  sorted by name, which this table has relationship of type  one to many .  Kind : instance property of  Table  Read only : true  See :  Example schema ,  Map  Example     for (let [name, table] of vendorTable.hasManyTables) {\n    console.log(table.name);\n}", 
            "title": "table.hasManyTables : Map.&lt;Table&gt;"
        }, 
        {
            "location": "/api/Table/#tablebelongstotables-maptable", 
            "text": "Tables  sorted by name, which this table has relationship of type  belongs to  which is reverse direction of  one to many .  Kind : instance property of  Table  Read only : true  See :  Example schema ,  Map  Example     for (let [name, table] of productTable.belongsToTables) {\n    console.log(table.name);\n}", 
            "title": "table.belongsToTables : Map.&lt;Table&gt;"
        }, 
        {
            "location": "/api/Table/#tablebelongstomanytables-maptable", 
            "text": "Tables  sorted by name, which this table has relationship of type  many to many .  Kind : instance property of  Table  Read only : true  See :  Example schema ,  Map  Example     // Cart (id) has many products (id) through line_item join table.\nfor (let [name, table] of cartTable.belongsToManyTables) {\n    console.log(table.name);\n}", 
            "title": "table.belongsToManyTables : Map.&lt;Table&gt;"
        }, 
        {
            "location": "/api/Table/#tablebelongstomanytablespk-maptable", 
            "text": "Tables  sorted by name, which this table has relationship of type  many to many . Includes\nonly tables joined by primary keys in join table.  Kind : instance property of  Table  Read only : true  See :  Example schema ,  Map  Example     // Cart (id) has many products (id) through line_item join table.\nfor (let [name, table] of cartTable.belongsToManyTables) {\n    console.log(table.name);\n}", 
            "title": "table.belongsToManyTablesPk : Map.&lt;Table&gt;"
        }, 
        {
            "location": "/api/Table/#tablem2mrelations-setm2mrelation", 
            "text": "Set of  many to many relationships  of the table.  M2MRelation  resembles has many through  and  belongs to many  relations in ORMs. It has some useful methods and information for generating ORM classes.  Kind : instance property of  Table  Read only : true", 
            "title": "table.m2mRelations : Set.&lt;M2MRelation&gt;"
        }, 
        {
            "location": "/api/Table/#tablem2mrelationspk-setm2mrelation", 
            "text": "Set of  many to many relationships  of the table. Different from  m2mRelations \nthis only includes relations joined by  Primary Foreign Keys  in join table.  Primary Foreign Keys  means\nforeign keys of join table which are also Primary Keys of join table at the same time. M2MRelation  resembles  has many through  and  belongs to many  relations in ORMs.\nIt has some useful methods and information for generating ORM classes.  Kind : instance property of  Table  Read only : true", 
            "title": "table.m2mRelationsPk : Set.&lt;M2MRelation&gt;"
        }, 
        {
            "location": "/api/Table/#tableo2mrelations-seto2mrelation", 
            "text": "Set of  one to many relationships  of the table.  O2MRelation  resembles has many  relations in ORMs. It has some useful methods and information for generating ORM classes.  Kind : instance property of  Table  Read only : true", 
            "title": "table.o2mRelations : Set.&lt;O2MRelation&gt;"
        }, 
        {
            "location": "/api/Table/#tablem2orelations-setm2orelation", 
            "text": "Set of  many to one relationships  of the table.  M2ORelation  resembles belongs to  relations in ORMs. It has some useful methods and information for generating ORM classes.  Kind : instance property of  Table  Read only : true", 
            "title": "table.m2oRelations : Set.&lt;M2ORelation&gt;"
        }, 
        {
            "location": "/api/Table/#tablerelations-arrayo2mrelationm2orelationm2mrelation", 
            "text": "List of all relationships of the table.  Kind : instance property of  Table  Read only : true", 
            "title": "table.relations : Array.&lt;(O2MRelation\\|M2ORelation\\|M2MRelation)&gt;"
        }, 
        {
            "location": "/api/Table/#tablegetpath-column-undefined", 
            "text": "Returns  Column  on given path relative to  Table .  Kind : instance method of  Table  Returns :  Column     undefined  - - Requested item.       Param  Type  Description      path  string  Path of the requested item in dot (.) notation such as 'public.contact'     Example     var column = table.get('contact'),      // Returns contact column in public table.", 
            "title": "table.get(path) \u21d2 Column &#124; undefined"
        }
    ]
}